   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"AD1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.SumChan,"aw",%nobits
  20              	SumChan:
  21 0000 00       		.space	1
  22              		.section	.bss.ModeFlg,"aw",%nobits
  25              	ModeFlg:
  26 0000 00       		.space	1
  27              		.comm	AdcLdd1_DeviceDataPtr,4,4
  28              		.section	.bss.SampleGroup,"aw",%nobits
  29              		.align	2
  32              	SampleGroup:
  33 0000 0000     		.space	2
  34              		.comm	AD1_OutV,4,4
  35 0002 0000     		.section	.bss.OutFlg,"aw",%nobits
  38              	OutFlg:
  39 0000 00       		.space	1
  40              		.section	.text.ClrSumV,"ax",%progbits
  41              		.align	2
  42              		.code	16
  43              		.thumb_func
  45              	ClrSumV:
  46              	.LFB0:
  47              		.file 1 "../Generated_Code/AD1.c"
   1:../Generated_Code/AD1.c **** /* ###################################################################
   2:../Generated_Code/AD1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AD1.c **** **     Filename    : AD1.c
   4:../Generated_Code/AD1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AD1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/AD1.c **** **     Component   : ADC
   7:../Generated_Code/AD1.c **** **     Version     : Component 01.690, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/AD1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AD1.c **** **     Date/Time   : 2016-01-22, 21:30, # CodeGen: 28
  10:../Generated_Code/AD1.c **** **     Abstract    :
  11:../Generated_Code/AD1.c **** **         This device "ADC" implements an A/D converter,
  12:../Generated_Code/AD1.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/AD1.c **** **     Settings    :
  14:../Generated_Code/AD1.c **** **          Component name                                 : AD1
  15:../Generated_Code/AD1.c **** **          A/D converter                                  : ADC0
  16:../Generated_Code/AD1.c **** **          Sharing                                        : Disabled
  17:../Generated_Code/AD1.c **** **          ADC_LDD                                        : ADC_LDD
  18:../Generated_Code/AD1.c **** **          Interrupt service/event                        : Enabled
  19:../Generated_Code/AD1.c **** **            A/D interrupt                                : INT_ADC0
  20:../Generated_Code/AD1.c **** **            A/D interrupt priority                       : medium priority
  21:../Generated_Code/AD1.c **** **          A/D channels                                   : 2
  22:../Generated_Code/AD1.c **** **            Channel0                                     : 
  23:../Generated_Code/AD1.c **** **              A/D channel (pin)                          : ADC0_DM0/ADC0_SE4a/PTE21/TPM1_CH1/UART
  24:../Generated_Code/AD1.c **** **              A/D channel (pin) signal                   : 
  25:../Generated_Code/AD1.c **** **              Mode select                                : Single Ended
  26:../Generated_Code/AD1.c **** **            Channel1                                     : 
  27:../Generated_Code/AD1.c **** **              A/D channel (pin)                          : ADC0_DP3/ADC0_SE3/PTE22/TPM2_CH0/UART2
  28:../Generated_Code/AD1.c **** **              A/D channel (pin) signal                   : 
  29:../Generated_Code/AD1.c **** **              Mode select                                : Single Ended
  30:../Generated_Code/AD1.c **** **          A/D resolution                                 : Autoselect
  31:../Generated_Code/AD1.c **** **          Conversion time                                : 9.615385 µs
  32:../Generated_Code/AD1.c **** **          Low-power mode                                 : Disabled
  33:../Generated_Code/AD1.c **** **          High-speed conversion mode                     : Disabled
  34:../Generated_Code/AD1.c **** **          Asynchro clock output                          : Disabled
  35:../Generated_Code/AD1.c **** **          Sample time                                    : 0 = short
  36:../Generated_Code/AD1.c **** **          Internal trigger                               : Disabled
  37:../Generated_Code/AD1.c **** **          Number of conversions                          : 1
  38:../Generated_Code/AD1.c **** **          Initialization                                 : 
  39:../Generated_Code/AD1.c **** **            Enabled in init. code                        : yes
  40:../Generated_Code/AD1.c **** **            Events enabled in init.                      : yes
  41:../Generated_Code/AD1.c **** **          CPU clock/speed selection                      : 
  42:../Generated_Code/AD1.c **** **            High speed mode                              : This component enabled
  43:../Generated_Code/AD1.c **** **            Low speed mode                               : This component disabled
  44:../Generated_Code/AD1.c **** **            Slow speed mode                              : This component disabled
  45:../Generated_Code/AD1.c **** **          High input limit                               : 1
  46:../Generated_Code/AD1.c **** **          Low input limit                                : 0
  47:../Generated_Code/AD1.c **** **          Get value directly                             : yes
  48:../Generated_Code/AD1.c **** **          Wait for result                                : yes
  49:../Generated_Code/AD1.c **** **     Contents    :
  50:../Generated_Code/AD1.c **** **         Measure    - byte AD1_Measure(bool WaitForResult);
  51:../Generated_Code/AD1.c **** **         GetValue16 - byte AD1_GetValue16(word *Values);
  52:../Generated_Code/AD1.c **** **         Calibrate  - byte AD1_Calibrate(bool WaitForResult);
  53:../Generated_Code/AD1.c **** **
  54:../Generated_Code/AD1.c **** **     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
  55:../Generated_Code/AD1.c **** **     All Rights Reserved.
  56:../Generated_Code/AD1.c **** **     
  57:../Generated_Code/AD1.c **** **     Redistribution and use in source and binary forms, with or without modification,
  58:../Generated_Code/AD1.c **** **     are permitted provided that the following conditions are met:
  59:../Generated_Code/AD1.c **** **     
  60:../Generated_Code/AD1.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  61:../Generated_Code/AD1.c **** **       of conditions and the following disclaimer.
  62:../Generated_Code/AD1.c **** **     
  63:../Generated_Code/AD1.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
  64:../Generated_Code/AD1.c **** **       list of conditions and the following disclaimer in the documentation and/or
  65:../Generated_Code/AD1.c **** **       other materials provided with the distribution.
  66:../Generated_Code/AD1.c **** **     
  67:../Generated_Code/AD1.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  68:../Generated_Code/AD1.c **** **       contributors may be used to endorse or promote products derived from this
  69:../Generated_Code/AD1.c **** **       software without specific prior written permission.
  70:../Generated_Code/AD1.c **** **     
  71:../Generated_Code/AD1.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  72:../Generated_Code/AD1.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  73:../Generated_Code/AD1.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  74:../Generated_Code/AD1.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
  75:../Generated_Code/AD1.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  76:../Generated_Code/AD1.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  77:../Generated_Code/AD1.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
  78:../Generated_Code/AD1.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  79:../Generated_Code/AD1.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  80:../Generated_Code/AD1.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  81:../Generated_Code/AD1.c **** **     
  82:../Generated_Code/AD1.c **** **     http: www.freescale.com
  83:../Generated_Code/AD1.c **** **     mail: support@freescale.com
  84:../Generated_Code/AD1.c **** ** ###################################################################*/
  85:../Generated_Code/AD1.c **** /*!
  86:../Generated_Code/AD1.c **** ** @file AD1.c
  87:../Generated_Code/AD1.c **** ** @version 01.00
  88:../Generated_Code/AD1.c **** ** @brief
  89:../Generated_Code/AD1.c **** **         This device "ADC" implements an A/D converter,
  90:../Generated_Code/AD1.c **** **         its control methods and interrupt/event handling procedure.
  91:../Generated_Code/AD1.c **** */         
  92:../Generated_Code/AD1.c **** /*!
  93:../Generated_Code/AD1.c **** **  @addtogroup AD1_module AD1 module documentation
  94:../Generated_Code/AD1.c **** **  @{
  95:../Generated_Code/AD1.c **** */         
  96:../Generated_Code/AD1.c **** 
  97:../Generated_Code/AD1.c **** /* MODULE AD1. */
  98:../Generated_Code/AD1.c **** 
  99:../Generated_Code/AD1.c **** #include "Events.h"
 100:../Generated_Code/AD1.c **** #include "AD1.h"
 101:../Generated_Code/AD1.c **** 
 102:../Generated_Code/AD1.c **** #ifdef __cplusplus
 103:../Generated_Code/AD1.c **** extern "C" {
 104:../Generated_Code/AD1.c **** #endif 
 105:../Generated_Code/AD1.c **** #define STOP            0x00U          /* STOP state           */
 106:../Generated_Code/AD1.c **** #define MEASURE         0x01U          /* MESURE state         */
 107:../Generated_Code/AD1.c **** #define CONTINUOUS      0x02U          /* CONTINUOUS state     */
 108:../Generated_Code/AD1.c **** #define SINGLE          0x03U          /* SINGLE state         */
 109:../Generated_Code/AD1.c **** #define CALIBRATING     0x04U          /* CALIBRATING state    */
 110:../Generated_Code/AD1.c **** 
 111:../Generated_Code/AD1.c **** static volatile byte SumChan;          /* Counter of measured channels */
 112:../Generated_Code/AD1.c **** static volatile byte ModeFlg;          /* Current state of device */
 113:../Generated_Code/AD1.c **** LDD_TDeviceData *AdcLdd1_DeviceDataPtr; /* Device data pointer */
 114:../Generated_Code/AD1.c **** /* Sample group configuration */
 115:../Generated_Code/AD1.c **** static LDD_ADC_TSample SampleGroup[AD1_SAMPLE_GROUP_SIZE];
 116:../Generated_Code/AD1.c **** /* Measure multiple channels flags  */
 117:../Generated_Code/AD1.c **** /* Temporary buffer for converting results */
 118:../Generated_Code/AD1.c **** volatile word AD1_OutV[AD1_SAMPLE_GROUP_SIZE]; /* Sum of measured values */
 119:../Generated_Code/AD1.c **** /* Calibration in progress flag */
 120:../Generated_Code/AD1.c **** static volatile bool OutFlg;           /* Measurement finish flag */
 121:../Generated_Code/AD1.c **** 
 122:../Generated_Code/AD1.c **** /*
 123:../Generated_Code/AD1.c **** ** ===================================================================
 124:../Generated_Code/AD1.c **** **     Method      :  ClrSumV (component ADC)
 125:../Generated_Code/AD1.c **** **
 126:../Generated_Code/AD1.c **** **     Description :
 127:../Generated_Code/AD1.c **** **         The method clears the internal buffers used to store sum of a 
 128:../Generated_Code/AD1.c **** **         number of last conversions.
 129:../Generated_Code/AD1.c **** **         This method is internal. It is used by Processor Expert only.
 130:../Generated_Code/AD1.c **** ** ===================================================================
 131:../Generated_Code/AD1.c **** */
 132:../Generated_Code/AD1.c **** static void ClrSumV(void)
 133:../Generated_Code/AD1.c **** {
  48              		.loc 1 133 0
  49              		.cfi_startproc
  50 0000 80B5     		push	{r7, lr}
  51              	.LCFI0:
  52              		.cfi_def_cfa_offset 8
  53              		.cfi_offset 7, -8
  54              		.cfi_offset 14, -4
  55 0002 00AF     		add	r7, sp, #0
  56              	.LCFI1:
  57              		.cfi_def_cfa_register 7
 134:../Generated_Code/AD1.c ****   AD1_OutV[0] = 0U;                    /* Set variable for storing measured values to 0 */
  58              		.loc 1 134 0
  59 0004 034B     		ldr	r3, .L2
  60 0006 0022     		mov	r2, #0
  61 0008 1A80     		strh	r2, [r3]
 135:../Generated_Code/AD1.c ****   AD1_OutV[1] = 0U;                    /* Set variable for storing measured values to 0 */
  62              		.loc 1 135 0
  63 000a 024B     		ldr	r3, .L2
  64 000c 0022     		mov	r2, #0
  65 000e 5A80     		strh	r2, [r3, #2]
 136:../Generated_Code/AD1.c **** }
  66              		.loc 1 136 0
  67 0010 BD46     		mov	sp, r7
  68              		@ sp needed for prologue
  69 0012 80BD     		pop	{r7, pc}
  70              	.L3:
  71              		.align	2
  72              	.L2:
  73 0014 00000000 		.word	AD1_OutV
  74              		.cfi_endproc
  75              	.LFE0:
  77              		.section	.text.AD1_HWEnDi,"ax",%progbits
  78              		.align	2
  79              		.global	AD1_HWEnDi
  80              		.code	16
  81              		.thumb_func
  83              	AD1_HWEnDi:
  84              	.LFB1:
 137:../Generated_Code/AD1.c **** 
 138:../Generated_Code/AD1.c **** /*
 139:../Generated_Code/AD1.c **** ** ===================================================================
 140:../Generated_Code/AD1.c **** **     Method      :  AD1_HWEnDi (component ADC)
 141:../Generated_Code/AD1.c **** **
 142:../Generated_Code/AD1.c **** **     Description :
 143:../Generated_Code/AD1.c **** **         Enables or disables the peripheral(s) associated with the 
 144:../Generated_Code/AD1.c **** **         component. The method is called automatically as a part of the 
 145:../Generated_Code/AD1.c **** **         Enable and Disable methods and several internal methods.
 146:../Generated_Code/AD1.c **** **         This method is internal. It is used by Processor Expert only.
 147:../Generated_Code/AD1.c **** ** ===================================================================
 148:../Generated_Code/AD1.c **** */
 149:../Generated_Code/AD1.c **** void AD1_HWEnDi(void)
 150:../Generated_Code/AD1.c **** {
  85              		.loc 1 150 0
  86              		.cfi_startproc
  87 0000 80B5     		push	{r7, lr}
  88              	.LCFI2:
  89              		.cfi_def_cfa_offset 8
  90              		.cfi_offset 7, -8
  91              		.cfi_offset 14, -4
  92 0002 00AF     		add	r7, sp, #0
  93              	.LCFI3:
  94              		.cfi_def_cfa_register 7
 151:../Generated_Code/AD1.c ****   if (ModeFlg) {                       /* Start or stop measurement? */
  95              		.loc 1 151 0
  96 0004 0F4B     		ldr	r3, .L6
  97 0006 1B78     		ldrb	r3, [r3]
  98 0008 DBB2     		uxtb	r3, r3
  99 000a 002B     		cmp	r3, #0
 100 000c 17D0     		beq	.L4
 152:../Generated_Code/AD1.c ****     OutFlg = FALSE;                    /* Output values aren't available */
 101              		.loc 1 152 0
 102 000e 0E4B     		ldr	r3, .L6+4
 103 0010 0022     		mov	r2, #0
 104 0012 1A70     		strb	r2, [r3]
 153:../Generated_Code/AD1.c ****     SumChan = 0U;                      /* Set the counter of measured channels to 0 */
 105              		.loc 1 153 0
 106 0014 0D4B     		ldr	r3, .L6+8
 107 0016 0022     		mov	r2, #0
 108 0018 1A70     		strb	r2, [r3]
 154:../Generated_Code/AD1.c ****     ClrSumV();                         /* Clear measured values */
 109              		.loc 1 154 0
 110 001a FFF7FEFF 		bl	ClrSumV
 155:../Generated_Code/AD1.c ****     SampleGroup[0].ChannelIdx = 0U;
 111              		.loc 1 155 0
 112 001e 0C4B     		ldr	r3, .L6+12
 113 0020 0022     		mov	r2, #0
 114 0022 1A70     		strb	r2, [r3]
 156:../Generated_Code/AD1.c ****     (void)AdcLdd1_CreateSampleGroup(AdcLdd1_DeviceDataPtr, (LDD_ADC_TSample *)SampleGroup, 1U); /* 
 115              		.loc 1 156 0
 116 0024 0B4B     		ldr	r3, .L6+16
 117 0026 1A68     		ldr	r2, [r3]
 118 0028 094B     		ldr	r3, .L6+12
 119 002a 101C     		mov	r0, r2
 120 002c 191C     		mov	r1, r3
 121 002e 0122     		mov	r2, #1
 122 0030 FFF7FEFF 		bl	AdcLdd1_CreateSampleGroup
 157:../Generated_Code/AD1.c ****     (void)AdcLdd1_StartSingleMeasurement(AdcLdd1_DeviceDataPtr);
 123              		.loc 1 157 0
 124 0034 074B     		ldr	r3, .L6+16
 125 0036 1B68     		ldr	r3, [r3]
 126 0038 181C     		mov	r0, r3
 127 003a FFF7FEFF 		bl	AdcLdd1_StartSingleMeasurement
 128              	.L4:
 158:../Generated_Code/AD1.c ****   }
 159:../Generated_Code/AD1.c **** }
 129              		.loc 1 159 0
 130 003e BD46     		mov	sp, r7
 131              		@ sp needed for prologue
 132 0040 80BD     		pop	{r7, pc}
 133              	.L7:
 134 0042 C046     		.align	2
 135              	.L6:
 136 0044 00000000 		.word	ModeFlg
 137 0048 00000000 		.word	OutFlg
 138 004c 00000000 		.word	SumChan
 139 0050 00000000 		.word	SampleGroup
 140 0054 00000000 		.word	AdcLdd1_DeviceDataPtr
 141              		.cfi_endproc
 142              	.LFE1:
 144              		.section	.text.AD1_Measure,"ax",%progbits
 145              		.align	2
 146              		.global	AD1_Measure
 147              		.code	16
 148              		.thumb_func
 150              	AD1_Measure:
 151              	.LFB2:
 160:../Generated_Code/AD1.c **** 
 161:../Generated_Code/AD1.c **** /*
 162:../Generated_Code/AD1.c **** ** ===================================================================
 163:../Generated_Code/AD1.c **** **     Method      :  AD1_Measure (component ADC)
 164:../Generated_Code/AD1.c **** */
 165:../Generated_Code/AD1.c **** /*!
 166:../Generated_Code/AD1.c **** **     @brief
 167:../Generated_Code/AD1.c **** **         This method performs one measurement on all channels that
 168:../Generated_Code/AD1.c **** **         are set in the component inspector. (Note: If the [number of
 169:../Generated_Code/AD1.c **** **         conversions] is more than one the conversion of A/D channels
 170:../Generated_Code/AD1.c **** **         is performed specified number of times.)
 171:../Generated_Code/AD1.c **** **     @param
 172:../Generated_Code/AD1.c **** **         WaitForResult   - Wait for a result of a
 173:../Generated_Code/AD1.c **** **                           conversion. If [interrupt service] is
 174:../Generated_Code/AD1.c **** **                           disabled, A/D peripheral doesn't support
 175:../Generated_Code/AD1.c **** **                           measuring all channels at once or Autoscan
 176:../Generated_Code/AD1.c **** **                           mode property isn't enabled and at the same
 177:../Generated_Code/AD1.c **** **                           time the [number of channels] is greater
 178:../Generated_Code/AD1.c **** **                           than 1, then the WaitForResult parameter is
 179:../Generated_Code/AD1.c **** **                           ignored and the method waits for each
 180:../Generated_Code/AD1.c **** **                           result every time. If the [interrupt
 181:../Generated_Code/AD1.c **** **                           service] is disabled and a [number of
 182:../Generated_Code/AD1.c **** **                           conversions] is greater than 1, the
 183:../Generated_Code/AD1.c **** **                           parameter is ignored and the method also
 184:../Generated_Code/AD1.c **** **                           waits for each result every time.
 185:../Generated_Code/AD1.c **** **     @return
 186:../Generated_Code/AD1.c **** **                         - Error code, possible codes:
 187:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 188:../Generated_Code/AD1.c **** **                           ERR_SPEED - This device does not work in
 189:../Generated_Code/AD1.c **** **                           the active speed mode
 190:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Device is disabled
 191:../Generated_Code/AD1.c **** **                           ERR_BUSY - A conversion is already running
 192:../Generated_Code/AD1.c **** */
 193:../Generated_Code/AD1.c **** /* ===================================================================*/
 194:../Generated_Code/AD1.c **** byte AD1_Measure(bool WaitForResult)
 195:../Generated_Code/AD1.c **** {
 152              		.loc 1 195 0
 153              		.cfi_startproc
 154 0000 80B5     		push	{r7, lr}
 155              	.LCFI4:
 156              		.cfi_def_cfa_offset 8
 157              		.cfi_offset 7, -8
 158              		.cfi_offset 14, -4
 159 0002 82B0     		sub	sp, sp, #8
 160              	.LCFI5:
 161              		.cfi_def_cfa_offset 16
 162 0004 00AF     		add	r7, sp, #0
 163              	.LCFI6:
 164              		.cfi_def_cfa_register 7
 165 0006 021C     		mov	r2, r0
 166 0008 FB1D     		add	r3, r7, #7
 167 000a 1A70     		strb	r2, [r3]
 196:../Generated_Code/AD1.c ****   if (ModeFlg != STOP) {               /* Is the device in different mode than "stop"? */
 168              		.loc 1 196 0
 169 000c 0D4B     		ldr	r3, .L13
 170 000e 1B78     		ldrb	r3, [r3]
 171 0010 DBB2     		uxtb	r3, r3
 172 0012 002B     		cmp	r3, #0
 173 0014 01D0     		beq	.L9
 197:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* If yes then error */
 174              		.loc 1 197 0
 175 0016 0823     		mov	r3, #8
 176 0018 0FE0     		b	.L10
 177              	.L9:
 198:../Generated_Code/AD1.c ****   }
 199:../Generated_Code/AD1.c ****   ModeFlg = MEASURE;                   /* Set state of device to the measure mode */
 178              		.loc 1 199 0
 179 001a 0A4B     		ldr	r3, .L13
 180 001c 0122     		mov	r2, #1
 181 001e 1A70     		strb	r2, [r3]
 200:../Generated_Code/AD1.c ****   AD1_HWEnDi();                        /* Enable the device */
 182              		.loc 1 200 0
 183 0020 FFF7FEFF 		bl	AD1_HWEnDi
 201:../Generated_Code/AD1.c ****   if (WaitForResult) {                 /* Is WaitForResult TRUE? */
 184              		.loc 1 201 0
 185 0024 FB1D     		add	r3, r7, #7
 186 0026 1B78     		ldrb	r3, [r3]
 187 0028 002B     		cmp	r3, #0
 188 002a 05D0     		beq	.L11
 202:../Generated_Code/AD1.c ****     while (ModeFlg == MEASURE) {}      /* If yes then wait for end of measurement */
 189              		.loc 1 202 0
 190 002c C046     		mov	r8, r8
 191              	.L12:
 192              		.loc 1 202 0 is_stmt 0
 193 002e 054B     		ldr	r3, .L13
 194 0030 1B78     		ldrb	r3, [r3]
 195 0032 DBB2     		uxtb	r3, r3
 196 0034 012B     		cmp	r3, #1
 197 0036 FAD0     		beq	.L12
 198              	.L11:
 203:../Generated_Code/AD1.c ****   }
 204:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 199              		.loc 1 204 0 is_stmt 1
 200 0038 0023     		mov	r3, #0
 201              	.L10:
 205:../Generated_Code/AD1.c **** }
 202              		.loc 1 205 0
 203 003a 181C     		mov	r0, r3
 204 003c BD46     		mov	sp, r7
 205 003e 02B0     		add	sp, sp, #8
 206              		@ sp needed for prologue
 207 0040 80BD     		pop	{r7, pc}
 208              	.L14:
 209 0042 C046     		.align	2
 210              	.L13:
 211 0044 00000000 		.word	ModeFlg
 212              		.cfi_endproc
 213              	.LFE2:
 215              		.section	.text.AD1_GetValue16,"ax",%progbits
 216              		.align	2
 217              		.global	AD1_GetValue16
 218              		.code	16
 219              		.thumb_func
 221              	AD1_GetValue16:
 222              	.LFB3:
 206:../Generated_Code/AD1.c **** 
 207:../Generated_Code/AD1.c **** /*
 208:../Generated_Code/AD1.c **** ** ===================================================================
 209:../Generated_Code/AD1.c **** **     Method      :  AD1_GetValue16 (component ADC)
 210:../Generated_Code/AD1.c **** */
 211:../Generated_Code/AD1.c **** /*!
 212:../Generated_Code/AD1.c **** **     @brief
 213:../Generated_Code/AD1.c **** **         This method returns the last measured values of all channels.
 214:../Generated_Code/AD1.c **** **         Compared with [GetValue] method this method returns more
 215:../Generated_Code/AD1.c **** **         accurate result if the [number of conversions] is greater
 216:../Generated_Code/AD1.c **** **         than 1 and [AD resolution] is less than 16 bits. In addition,
 217:../Generated_Code/AD1.c **** **         the user code dependency on [AD resolution] is eliminated.
 218:../Generated_Code/AD1.c **** **     @param
 219:../Generated_Code/AD1.c **** **         Values          - Pointer to the array that contains
 220:../Generated_Code/AD1.c **** **                           the measured data.
 221:../Generated_Code/AD1.c **** **     @return
 222:../Generated_Code/AD1.c **** **                         - Error code, possible codes:
 223:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 224:../Generated_Code/AD1.c **** **                           ERR_SPEED - This device does not work in
 225:../Generated_Code/AD1.c **** **                           the active speed mode
 226:../Generated_Code/AD1.c **** **                           ERR_NOTAVAIL - Requested value not
 227:../Generated_Code/AD1.c **** **                           available
 228:../Generated_Code/AD1.c **** **                           ERR_OVERRUN - External trigger overrun flag
 229:../Generated_Code/AD1.c **** **                           was detected after the last value(s) was
 230:../Generated_Code/AD1.c **** **                           obtained (for example by GetValue). This
 231:../Generated_Code/AD1.c **** **                           error may not be supported on some CPUs
 232:../Generated_Code/AD1.c **** **                           (see generated code).
 233:../Generated_Code/AD1.c **** */
 234:../Generated_Code/AD1.c **** /* ===================================================================*/
 235:../Generated_Code/AD1.c **** byte AD1_GetValue16(word *Values)
 236:../Generated_Code/AD1.c **** {
 223              		.loc 1 236 0
 224              		.cfi_startproc
 225 0000 80B5     		push	{r7, lr}
 226              	.LCFI7:
 227              		.cfi_def_cfa_offset 8
 228              		.cfi_offset 7, -8
 229              		.cfi_offset 14, -4
 230 0002 82B0     		sub	sp, sp, #8
 231              	.LCFI8:
 232              		.cfi_def_cfa_offset 16
 233 0004 00AF     		add	r7, sp, #0
 234              	.LCFI9:
 235              		.cfi_def_cfa_register 7
 236 0006 7860     		str	r0, [r7, #4]
 237:../Generated_Code/AD1.c ****   if (!OutFlg) {                       /* Is output flag set? */
 237              		.loc 1 237 0
 238 0008 0B4B     		ldr	r3, .L18
 239 000a 1B78     		ldrb	r3, [r3]
 240 000c DBB2     		uxtb	r3, r3
 241 000e 002B     		cmp	r3, #0
 242 0010 01D1     		bne	.L16
 238:../Generated_Code/AD1.c ****     return ERR_NOTAVAIL;               /* If no then error */
 243              		.loc 1 238 0
 244 0012 0923     		mov	r3, #9
 245 0014 0BE0     		b	.L17
 246              	.L16:
 239:../Generated_Code/AD1.c ****   }
 240:../Generated_Code/AD1.c ****   Values[0] = AD1_OutV[0];             /* Save measured values to the output buffer */
 247              		.loc 1 240 0
 248 0016 094B     		ldr	r3, .L18+4
 249 0018 1B88     		ldrh	r3, [r3]
 250 001a 9AB2     		uxth	r2, r3
 251 001c 7B68     		ldr	r3, [r7, #4]
 252 001e 1A80     		strh	r2, [r3]
 241:../Generated_Code/AD1.c ****   Values[1] = AD1_OutV[1];             /* Save measured values to the output buffer */
 253              		.loc 1 241 0
 254 0020 7B68     		ldr	r3, [r7, #4]
 255 0022 0233     		add	r3, r3, #2
 256 0024 054A     		ldr	r2, .L18+4
 257 0026 5288     		ldrh	r2, [r2, #2]
 258 0028 92B2     		uxth	r2, r2
 259 002a 1A80     		strh	r2, [r3]
 242:../Generated_Code/AD1.c ****   return ERR_OK;                       /* OK */
 260              		.loc 1 242 0
 261 002c 0023     		mov	r3, #0
 262              	.L17:
 243:../Generated_Code/AD1.c **** }
 263              		.loc 1 243 0
 264 002e 181C     		mov	r0, r3
 265 0030 BD46     		mov	sp, r7
 266 0032 02B0     		add	sp, sp, #8
 267              		@ sp needed for prologue
 268 0034 80BD     		pop	{r7, pc}
 269              	.L19:
 270 0036 C046     		.align	2
 271              	.L18:
 272 0038 00000000 		.word	OutFlg
 273 003c 00000000 		.word	AD1_OutV
 274              		.cfi_endproc
 275              	.LFE3:
 277              		.section	.text.AD1_Calibrate,"ax",%progbits
 278              		.align	2
 279              		.global	AD1_Calibrate
 280              		.code	16
 281              		.thumb_func
 283              	AD1_Calibrate:
 284              	.LFB4:
 244:../Generated_Code/AD1.c **** 
 245:../Generated_Code/AD1.c **** /*
 246:../Generated_Code/AD1.c **** ** ===================================================================
 247:../Generated_Code/AD1.c **** **     Method      :  AD1_Calibrate (component ADC)
 248:../Generated_Code/AD1.c **** **     Description :
 249:../Generated_Code/AD1.c **** **         This method starts self calibration process. Calibration is
 250:../Generated_Code/AD1.c **** **         typically used to remove the effects of the gain and offset
 251:../Generated_Code/AD1.c **** **         from a specific reading.
 252:../Generated_Code/AD1.c **** **     Parameters  :
 253:../Generated_Code/AD1.c **** **         NAME            - DESCRIPTION
 254:../Generated_Code/AD1.c **** **         WaitForResult   - Wait for a result of
 255:../Generated_Code/AD1.c **** **                           calibration. If the <interrupt service> is
 256:../Generated_Code/AD1.c **** **                           disabled, the WaitForResult parameter is
 257:../Generated_Code/AD1.c **** **                           ignored and the method waits for
 258:../Generated_Code/AD1.c **** **                           calibration result every time.
 259:../Generated_Code/AD1.c **** **     Returns     :
 260:../Generated_Code/AD1.c **** **         ---             - Error code
 261:../Generated_Code/AD1.c **** **                           ERR_OK - OK
 262:../Generated_Code/AD1.c **** **                           ERR_BUSY - A conversion is already running
 263:../Generated_Code/AD1.c **** **                           ERR_SPEED - This device does not work in
 264:../Generated_Code/AD1.c **** **                           the active speed mode
 265:../Generated_Code/AD1.c **** **                           ERR_DISABLED - Device is disabled
 266:../Generated_Code/AD1.c **** **                           ERR_FAILED - Calibration hasn't been
 267:../Generated_Code/AD1.c **** **                           finished correctly
 268:../Generated_Code/AD1.c **** ** ===================================================================
 269:../Generated_Code/AD1.c **** */
 270:../Generated_Code/AD1.c **** byte AD1_Calibrate(bool WaitForResult)
 271:../Generated_Code/AD1.c **** {
 285              		.loc 1 271 0
 286              		.cfi_startproc
 287 0000 80B5     		push	{r7, lr}
 288              	.LCFI10:
 289              		.cfi_def_cfa_offset 8
 290              		.cfi_offset 7, -8
 291              		.cfi_offset 14, -4
 292 0002 82B0     		sub	sp, sp, #8
 293              	.LCFI11:
 294              		.cfi_def_cfa_offset 16
 295 0004 00AF     		add	r7, sp, #0
 296              	.LCFI12:
 297              		.cfi_def_cfa_register 7
 298 0006 021C     		mov	r2, r0
 299 0008 FB1D     		add	r3, r7, #7
 300 000a 1A70     		strb	r2, [r3]
 272:../Generated_Code/AD1.c ****   if (ModeFlg != STOP) {               /* Is the device in different mode than "stop"? */
 301              		.loc 1 272 0
 302 000c 1A4B     		ldr	r3, .L27
 303 000e 1B78     		ldrb	r3, [r3]
 304 0010 DBB2     		uxtb	r3, r3
 305 0012 002B     		cmp	r3, #0
 306 0014 01D0     		beq	.L21
 273:../Generated_Code/AD1.c ****     return ERR_BUSY;                   /* If yes then error */
 307              		.loc 1 273 0
 308 0016 0823     		mov	r3, #8
 309 0018 29E0     		b	.L22
 310              	.L21:
 274:../Generated_Code/AD1.c ****   }
 275:../Generated_Code/AD1.c ****   ModeFlg = CALIBRATING;               /* Set state of device to the calibration mode */
 311              		.loc 1 275 0
 312 001a 174B     		ldr	r3, .L27
 313 001c 0422     		mov	r2, #4
 314 001e 1A70     		strb	r2, [r3]
 276:../Generated_Code/AD1.c ****   (void)AdcLdd1_GetMeasurementCompleteStatus(AdcLdd1_DeviceDataPtr); /* Clear measurement complete 
 315              		.loc 1 276 0
 316 0020 164B     		ldr	r3, .L27+4
 317 0022 1B68     		ldr	r3, [r3]
 318 0024 181C     		mov	r0, r3
 319 0026 FFF7FEFF 		bl	AdcLdd1_GetMeasurementCompleteStatus
 277:../Generated_Code/AD1.c ****   (void)AdcLdd1_StartCalibration(AdcLdd1_DeviceDataPtr); /* Start calibration */
 320              		.loc 1 277 0
 321 002a 144B     		ldr	r3, .L27+4
 322 002c 1B68     		ldr	r3, [r3]
 323 002e 181C     		mov	r0, r3
 324 0030 FFF7FEFF 		bl	AdcLdd1_StartCalibration
 278:../Generated_Code/AD1.c ****   if (!WaitForResult) {                /* If doesn't wait for result */
 325              		.loc 1 278 0
 326 0034 FB1D     		add	r3, r7, #7
 327 0036 1B78     		ldrb	r3, [r3]
 328 0038 002B     		cmp	r3, #0
 329 003a 01D1     		bne	.L26
 279:../Generated_Code/AD1.c ****     return ERR_OK;                     /* then return ERR_OK, but user have to check the result of 
 330              		.loc 1 279 0
 331 003c 0023     		mov	r3, #0
 332 003e 16E0     		b	.L22
 333              	.L26:
 280:../Generated_Code/AD1.c ****   }
 281:../Generated_Code/AD1.c ****   while (!AdcLdd1_GetMeasurementCompleteStatus(AdcLdd1_DeviceDataPtr)) {}; /* Wait until calibratio
 334              		.loc 1 281 0
 335 0040 C046     		mov	r8, r8
 336              	.L24:
 337              		.loc 1 281 0 is_stmt 0
 338 0042 0E4B     		ldr	r3, .L27+4
 339 0044 1B68     		ldr	r3, [r3]
 340 0046 181C     		mov	r0, r3
 341 0048 FFF7FEFF 		bl	AdcLdd1_GetMeasurementCompleteStatus
 342 004c 031C     		mov	r3, r0
 343 004e 002B     		cmp	r3, #0
 344 0050 F7D0     		beq	.L24
 282:../Generated_Code/AD1.c ****   if (AdcLdd1_GetCalibrationResultStatus(AdcLdd1_DeviceDataPtr) != ERR_OK) { /* If calibration fail
 345              		.loc 1 282 0 is_stmt 1
 346 0052 0A4B     		ldr	r3, .L27+4
 347 0054 1B68     		ldr	r3, [r3]
 348 0056 181C     		mov	r0, r3
 349 0058 FFF7FEFF 		bl	AdcLdd1_GetCalibrationResultStatus
 350 005c 031C     		mov	r3, r0
 351 005e 002B     		cmp	r3, #0
 352 0060 04D0     		beq	.L25
 283:../Generated_Code/AD1.c ****     ModeFlg = STOP;                    /* Set the device to the stop mode */
 353              		.loc 1 283 0
 354 0062 054B     		ldr	r3, .L27
 355 0064 0022     		mov	r2, #0
 356 0066 1A70     		strb	r2, [r3]
 284:../Generated_Code/AD1.c ****     return ERR_FAILED;                 /* Return ERR_FAILED error code */
 357              		.loc 1 284 0
 358 0068 1B23     		mov	r3, #27
 359 006a 00E0     		b	.L22
 360              	.L25:
 285:../Generated_Code/AD1.c ****   }
 286:../Generated_Code/AD1.c ****   return ERR_OK;                       /* ADC device is now calibrated */
 361              		.loc 1 286 0
 362 006c 0023     		mov	r3, #0
 363              	.L22:
 287:../Generated_Code/AD1.c **** }
 364              		.loc 1 287 0
 365 006e 181C     		mov	r0, r3
 366 0070 BD46     		mov	sp, r7
 367 0072 02B0     		add	sp, sp, #8
 368              		@ sp needed for prologue
 369 0074 80BD     		pop	{r7, pc}
 370              	.L28:
 371 0076 C046     		.align	2
 372              	.L27:
 373 0078 00000000 		.word	ModeFlg
 374 007c 00000000 		.word	AdcLdd1_DeviceDataPtr
 375              		.cfi_endproc
 376              	.LFE4:
 378              		.section	.text.AdcLdd1_OnMeasurementComplete,"ax",%progbits
 379              		.align	2
 380              		.global	AdcLdd1_OnMeasurementComplete
 381              		.code	16
 382              		.thumb_func
 384              	AdcLdd1_OnMeasurementComplete:
 385              	.LFB5:
 288:../Generated_Code/AD1.c **** 
 289:../Generated_Code/AD1.c **** /*
 290:../Generated_Code/AD1.c **** ** ===================================================================
 291:../Generated_Code/AD1.c **** **     Method      :  AD1_OnMeasurementComplete (component ADC)
 292:../Generated_Code/AD1.c **** **
 293:../Generated_Code/AD1.c **** **     Description :
 294:../Generated_Code/AD1.c **** **         The method services the conversion complete interrupt of the 
 295:../Generated_Code/AD1.c **** **         selected peripheral(s) and eventually invokes the beans 
 296:../Generated_Code/AD1.c **** **         event(s).
 297:../Generated_Code/AD1.c **** **         This method is internal. It is used by Processor Expert only.
 298:../Generated_Code/AD1.c **** ** ===================================================================
 299:../Generated_Code/AD1.c **** */
 300:../Generated_Code/AD1.c **** void AdcLdd1_OnMeasurementComplete(LDD_TUserData *UserDataPtr)
 301:../Generated_Code/AD1.c **** {
 386              		.loc 1 301 0
 387              		.cfi_startproc
 388 0000 80B5     		push	{r7, lr}
 389              	.LCFI13:
 390              		.cfi_def_cfa_offset 8
 391              		.cfi_offset 7, -8
 392              		.cfi_offset 14, -4
 393 0002 82B0     		sub	sp, sp, #8
 394              	.LCFI14:
 395              		.cfi_def_cfa_offset 16
 396 0004 00AF     		add	r7, sp, #0
 397              	.LCFI15:
 398              		.cfi_def_cfa_register 7
 399 0006 7860     		str	r0, [r7, #4]
 302:../Generated_Code/AD1.c ****   (void)UserDataPtr;                   /* Parameter is not used, suppress unused argument warning *
 303:../Generated_Code/AD1.c ****   if (ModeFlg == CALIBRATING) {        /* If the driver is in CALIBRATING mode */
 400              		.loc 1 303 0
 401 0008 244B     		ldr	r3, .L33
 402 000a 1B78     		ldrb	r3, [r3]
 403 000c DBB2     		uxtb	r3, r3
 404 000e 042B     		cmp	r3, #4
 405 0010 0AD1     		bne	.L30
 304:../Generated_Code/AD1.c ****     (void)AdcLdd1_GetCalibrationResultStatus(AdcLdd1_DeviceDataPtr);
 406              		.loc 1 304 0
 407 0012 234B     		ldr	r3, .L33+4
 408 0014 1B68     		ldr	r3, [r3]
 409 0016 181C     		mov	r0, r3
 410 0018 FFF7FEFF 		bl	AdcLdd1_GetCalibrationResultStatus
 305:../Generated_Code/AD1.c ****     ModeFlg = STOP;                    /* Set the device to the stop mode */
 411              		.loc 1 305 0
 412 001c 1F4B     		ldr	r3, .L33
 413 001e 0022     		mov	r2, #0
 414 0020 1A70     		strb	r2, [r3]
 306:../Generated_Code/AD1.c ****     AD1_OnCalibrationEnd();            /* If yes then invoke user event */
 415              		.loc 1 306 0
 416 0022 FFF7FEFF 		bl	AD1_OnCalibrationEnd
 307:../Generated_Code/AD1.c ****     return;                            /* Return from interrupt */
 417              		.loc 1 307 0
 418 0026 35E0     		b	.L29
 419              	.L30:
 308:../Generated_Code/AD1.c ****   }
 309:../Generated_Code/AD1.c ****   AdcLdd1_GetMeasuredValues(AdcLdd1_DeviceDataPtr, (LDD_TData *)&AD1_OutV[SumChan]);
 420              		.loc 1 309 0
 421 0028 1D4B     		ldr	r3, .L33+4
 422 002a 1A68     		ldr	r2, [r3]
 423 002c 1D4B     		ldr	r3, .L33+8
 424 002e 1B78     		ldrb	r3, [r3]
 425 0030 DBB2     		uxtb	r3, r3
 426 0032 5900     		lsl	r1, r3, #1
 427 0034 1C4B     		ldr	r3, .L33+12
 428 0036 CB18     		add	r3, r1, r3
 429 0038 101C     		mov	r0, r2
 430 003a 191C     		mov	r1, r3
 431 003c FFF7FEFF 		bl	AdcLdd1_GetMeasuredValues
 310:../Generated_Code/AD1.c ****   SumChan++;                           /* Increase counter of measured channels*/
 432              		.loc 1 310 0
 433 0040 184B     		ldr	r3, .L33+8
 434 0042 1B78     		ldrb	r3, [r3]
 435 0044 DBB2     		uxtb	r3, r3
 436 0046 0133     		add	r3, r3, #1
 437 0048 DAB2     		uxtb	r2, r3
 438 004a 164B     		ldr	r3, .L33+8
 439 004c 1A70     		strb	r2, [r3]
 311:../Generated_Code/AD1.c ****   if (SumChan == 2U) {                 /* Is number of measured channels equal to the number of cha
 440              		.loc 1 311 0
 441 004e 154B     		ldr	r3, .L33+8
 442 0050 1B78     		ldrb	r3, [r3]
 443 0052 DBB2     		uxtb	r3, r3
 444 0054 022B     		cmp	r3, #2
 445 0056 0BD1     		bne	.L32
 312:../Generated_Code/AD1.c ****     SumChan = 0U;                      /* If yes then set the counter of measured channels to 0 */
 446              		.loc 1 312 0
 447 0058 124B     		ldr	r3, .L33+8
 448 005a 0022     		mov	r2, #0
 449 005c 1A70     		strb	r2, [r3]
 313:../Generated_Code/AD1.c ****     OutFlg = TRUE;                     /* Measured values are available */
 450              		.loc 1 313 0
 451 005e 134B     		ldr	r3, .L33+16
 452 0060 0122     		mov	r2, #1
 453 0062 1A70     		strb	r2, [r3]
 314:../Generated_Code/AD1.c ****     AD1_OnEnd();                       /* If yes then invoke user event */
 454              		.loc 1 314 0
 455 0064 FFF7FEFF 		bl	AD1_OnEnd
 315:../Generated_Code/AD1.c ****     ModeFlg = STOP;                    /* Set the device to the stop mode */
 456              		.loc 1 315 0
 457 0068 0C4B     		ldr	r3, .L33
 458 006a 0022     		mov	r2, #0
 459 006c 1A70     		strb	r2, [r3]
 316:../Generated_Code/AD1.c ****     return;                            /* Return from interrupt */
 460              		.loc 1 316 0
 461 006e 11E0     		b	.L29
 462              	.L32:
 317:../Generated_Code/AD1.c ****   }
 318:../Generated_Code/AD1.c ****   SampleGroup[0].ChannelIdx = SumChan; /* Start measurement of next channel */
 463              		.loc 1 318 0
 464 0070 0C4B     		ldr	r3, .L33+8
 465 0072 1B78     		ldrb	r3, [r3]
 466 0074 DAB2     		uxtb	r2, r3
 467 0076 0E4B     		ldr	r3, .L33+20
 468 0078 1A70     		strb	r2, [r3]
 319:../Generated_Code/AD1.c ****   (void)AdcLdd1_CreateSampleGroup(AdcLdd1_DeviceDataPtr, (LDD_ADC_TSample *)SampleGroup, 1U); /* Co
 469              		.loc 1 319 0
 470 007a 094B     		ldr	r3, .L33+4
 471 007c 1A68     		ldr	r2, [r3]
 472 007e 0C4B     		ldr	r3, .L33+20
 473 0080 101C     		mov	r0, r2
 474 0082 191C     		mov	r1, r3
 475 0084 0122     		mov	r2, #1
 476 0086 FFF7FEFF 		bl	AdcLdd1_CreateSampleGroup
 320:../Generated_Code/AD1.c ****   (void)AdcLdd1_StartSingleMeasurement(AdcLdd1_DeviceDataPtr);
 477              		.loc 1 320 0
 478 008a 054B     		ldr	r3, .L33+4
 479 008c 1B68     		ldr	r3, [r3]
 480 008e 181C     		mov	r0, r3
 481 0090 FFF7FEFF 		bl	AdcLdd1_StartSingleMeasurement
 482              	.L29:
 321:../Generated_Code/AD1.c **** }
 483              		.loc 1 321 0
 484 0094 BD46     		mov	sp, r7
 485 0096 02B0     		add	sp, sp, #8
 486              		@ sp needed for prologue
 487 0098 80BD     		pop	{r7, pc}
 488              	.L34:
 489 009a C046     		.align	2
 490              	.L33:
 491 009c 00000000 		.word	ModeFlg
 492 00a0 00000000 		.word	AdcLdd1_DeviceDataPtr
 493 00a4 00000000 		.word	SumChan
 494 00a8 00000000 		.word	AD1_OutV
 495 00ac 00000000 		.word	OutFlg
 496 00b0 00000000 		.word	SampleGroup
 497              		.cfi_endproc
 498              	.LFE5:
 500              		.section	.text.AD1_Init,"ax",%progbits
 501              		.align	2
 502              		.global	AD1_Init
 503              		.code	16
 504              		.thumb_func
 506              	AD1_Init:
 507              	.LFB6:
 322:../Generated_Code/AD1.c **** 
 323:../Generated_Code/AD1.c **** /*
 324:../Generated_Code/AD1.c **** ** ===================================================================
 325:../Generated_Code/AD1.c **** **     Method      :  AD1_Init (component ADC)
 326:../Generated_Code/AD1.c **** **
 327:../Generated_Code/AD1.c **** **     Description :
 328:../Generated_Code/AD1.c **** **         Initializes the associated peripheral(s) and the component 
 329:../Generated_Code/AD1.c **** **         internal variables. The method is called automatically as a 
 330:../Generated_Code/AD1.c **** **         part of the application initialization code.
 331:../Generated_Code/AD1.c **** **         This method is internal. It is used by Processor Expert only.
 332:../Generated_Code/AD1.c **** ** ===================================================================
 333:../Generated_Code/AD1.c **** */
 334:../Generated_Code/AD1.c **** void AD1_Init(void)
 335:../Generated_Code/AD1.c **** {
 508              		.loc 1 335 0
 509              		.cfi_startproc
 510 0000 80B5     		push	{r7, lr}
 511              	.LCFI16:
 512              		.cfi_def_cfa_offset 8
 513              		.cfi_offset 7, -8
 514              		.cfi_offset 14, -4
 515 0002 00AF     		add	r7, sp, #0
 516              	.LCFI17:
 517              		.cfi_def_cfa_register 7
 336:../Generated_Code/AD1.c ****   OutFlg = FALSE;                      /* No measured value */
 518              		.loc 1 336 0
 519 0004 064B     		ldr	r3, .L36
 520 0006 0022     		mov	r2, #0
 521 0008 1A70     		strb	r2, [r3]
 337:../Generated_Code/AD1.c ****   ModeFlg = STOP;                      /* Device isn't running */
 522              		.loc 1 337 0
 523 000a 064B     		ldr	r3, .L36+4
 524 000c 0022     		mov	r2, #0
 525 000e 1A70     		strb	r2, [r3]
 338:../Generated_Code/AD1.c ****   AdcLdd1_DeviceDataPtr = AdcLdd1_Init(NULL); /* Calling init method of the inherited component */
 526              		.loc 1 338 0
 527 0010 0020     		mov	r0, #0
 528 0012 FFF7FEFF 		bl	AdcLdd1_Init
 529 0016 021C     		mov	r2, r0
 530 0018 034B     		ldr	r3, .L36+8
 531 001a 1A60     		str	r2, [r3]
 339:../Generated_Code/AD1.c **** }
 532              		.loc 1 339 0
 533 001c BD46     		mov	sp, r7
 534              		@ sp needed for prologue
 535 001e 80BD     		pop	{r7, pc}
 536              	.L37:
 537              		.align	2
 538              	.L36:
 539 0020 00000000 		.word	OutFlg
 540 0024 00000000 		.word	ModeFlg
 541 0028 00000000 		.word	AdcLdd1_DeviceDataPtr
 542              		.cfi_endproc
 543              	.LFE6:
 545              		.text
 546              	.Letext0:
 547              		.file 2 "D:/CodeWarrior/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 548              		.file 3 "D:/PlikiI/Synergia/Jacht/workspace_yacht/I2C_1/Generated_Code/PE_Types.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AD1.c
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:20     .bss.SumChan:00000000 SumChan
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:21     .bss.SumChan:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:25     .bss.ModeFlg:00000000 ModeFlg
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:26     .bss.ModeFlg:00000000 $d
                            *COM*:00000004 AdcLdd1_DeviceDataPtr
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:29     .bss.SampleGroup:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:32     .bss.SampleGroup:00000000 SampleGroup
                            *COM*:00000004 AD1_OutV
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:38     .bss.OutFlg:00000000 OutFlg
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:39     .bss.OutFlg:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:41     .text.ClrSumV:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:45     .text.ClrSumV:00000000 ClrSumV
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:73     .text.ClrSumV:00000014 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:78     .text.AD1_HWEnDi:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:83     .text.AD1_HWEnDi:00000000 AD1_HWEnDi
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:136    .text.AD1_HWEnDi:00000044 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:145    .text.AD1_Measure:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:150    .text.AD1_Measure:00000000 AD1_Measure
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:211    .text.AD1_Measure:00000044 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:216    .text.AD1_GetValue16:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:221    .text.AD1_GetValue16:00000000 AD1_GetValue16
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:272    .text.AD1_GetValue16:00000038 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:278    .text.AD1_Calibrate:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:283    .text.AD1_Calibrate:00000000 AD1_Calibrate
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:373    .text.AD1_Calibrate:00000078 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:379    .text.AdcLdd1_OnMeasurementComplete:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:384    .text.AdcLdd1_OnMeasurementComplete:00000000 AdcLdd1_OnMeasurementComplete
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:491    .text.AdcLdd1_OnMeasurementComplete:0000009c $d
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:501    .text.AD1_Init:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:506    .text.AD1_Init:00000000 AD1_Init
C:\Users\SKRA~1\AppData\Local\Temp\ccz7ou3e.s:539    .text.AD1_Init:00000020 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
AdcLdd1_CreateSampleGroup
AdcLdd1_StartSingleMeasurement
AdcLdd1_GetMeasurementCompleteStatus
AdcLdd1_StartCalibration
AdcLdd1_GetCalibrationResultStatus
AD1_OnCalibrationEnd
AdcLdd1_GetMeasuredValues
AD1_OnEnd
AdcLdd1_Init
