   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"AdcLdd1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.rodata.ChannelToPin,"a",%progbits
  18              		.align	2
  21              	ChannelToPin:
  22 0000 40       		.byte	64
  23 0001 44       		.byte	68
  24 0002 0000     		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  25              		.align	2
  28              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  29 0000 00000000 		.space	8
  29      00000000 
  30              		.section	.bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  31              		.align	2
  34              	INT_ADC0__DEFAULT_RTOS_ISRPARAM:
  35 0000 00000000 		.space	4
  36              		.section	.text.AdcLdd1_Init,"ax",%progbits
  37              		.align	2
  38              		.global	AdcLdd1_Init
  39              		.code	16
  40              		.thumb_func
  42              	AdcLdd1_Init:
  43              	.LFB0:
  44              		.file 1 "../Generated_Code/AdcLdd1.c"
   1:../Generated_Code/AdcLdd1.c **** /* ###################################################################
   2:../Generated_Code/AdcLdd1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/AdcLdd1.c **** **     Filename    : AdcLdd1.c
   4:../Generated_Code/AdcLdd1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/AdcLdd1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/AdcLdd1.c **** **     Component   : ADC_LDD
   7:../Generated_Code/AdcLdd1.c **** **     Version     : Component 01.183, Driver 01.08, CPU db: 3.00.000
   8:../Generated_Code/AdcLdd1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/AdcLdd1.c **** **     Date/Time   : 2016-01-22, 19:55, # CodeGen: 27
  10:../Generated_Code/AdcLdd1.c **** **     Abstract    :
  11:../Generated_Code/AdcLdd1.c **** **         This device "ADC_LDD" implements an A/D converter,
  12:../Generated_Code/AdcLdd1.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/AdcLdd1.c **** **     Settings    :
  14:../Generated_Code/AdcLdd1.c **** **          Component name                                 : AdcLdd1
  15:../Generated_Code/AdcLdd1.c **** **          A/D converter                                  : ADC0
  16:../Generated_Code/AdcLdd1.c **** **          Discontinuous mode                             : no
  17:../Generated_Code/AdcLdd1.c **** **          Interrupt service/event                        : Enabled
  18:../Generated_Code/AdcLdd1.c **** **            A/D interrupt                                : INT_ADC0
  19:../Generated_Code/AdcLdd1.c **** **            A/D interrupt priority                       : medium priority
  20:../Generated_Code/AdcLdd1.c **** **          DMA                                            : Disabled
  21:../Generated_Code/AdcLdd1.c **** **          A/D channel list                               : 2
  22:../Generated_Code/AdcLdd1.c **** **            Channel 0                                    : 
  23:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  24:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  25:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_DP0/ADC0_SE0/PTE20/TPM1_CH0/UART0
  26:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  27:../Generated_Code/AdcLdd1.c **** **            Channel 1                                    : 
  28:../Generated_Code/AdcLdd1.c **** **              Channel mode                               : Single Ended
  29:../Generated_Code/AdcLdd1.c **** **                Input                                    : 
  30:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin)                      : ADC0_DM0/ADC0_SE4a/PTE21/TPM1_CH1/UART
  31:../Generated_Code/AdcLdd1.c **** **                  A/D channel (pin) signal               : 
  32:../Generated_Code/AdcLdd1.c **** **          Static sample groups                           : Disabled
  33:../Generated_Code/AdcLdd1.c **** **          A/D resolution                                 : Autoselect
  34:../Generated_Code/AdcLdd1.c **** **          Low-power mode                                 : Disabled
  35:../Generated_Code/AdcLdd1.c **** **          High-speed conversion mode                     : Disabled
  36:../Generated_Code/AdcLdd1.c **** **          Asynchro clock output                          : Disabled
  37:../Generated_Code/AdcLdd1.c **** **          Sample time                                    : 4 clock periods
  38:../Generated_Code/AdcLdd1.c **** **          Number of conversions                          : 1
  39:../Generated_Code/AdcLdd1.c **** **          Conversion time                                : 9.615385 µs
  40:../Generated_Code/AdcLdd1.c **** **          ADC clock                                      : 2.6 MHz (384.615 ns)
  41:../Generated_Code/AdcLdd1.c **** **          Single conversion time - Single-ended          : 16.746 us
  42:../Generated_Code/AdcLdd1.c **** **          Single conversion time - Differential          : 20.208 us
  43:../Generated_Code/AdcLdd1.c **** **          Additional conversion time - Single-ended      : 9.615 us
  44:../Generated_Code/AdcLdd1.c **** **          Additional conversion time - Differential      : 13.076 us
  45:../Generated_Code/AdcLdd1.c **** **          Result type                                    : unsigned 16 bits, right justified
  46:../Generated_Code/AdcLdd1.c **** **          Trigger                                        : Disabled
  47:../Generated_Code/AdcLdd1.c **** **          Voltage reference                              : 
  48:../Generated_Code/AdcLdd1.c **** **            High voltage reference                       : 
  49:../Generated_Code/AdcLdd1.c **** **              Volt. ref. pin                             : VREFH
  50:../Generated_Code/AdcLdd1.c **** **              Volt. ref pin signal                       : 
  51:../Generated_Code/AdcLdd1.c **** **            Low voltage reference                        : 
  52:../Generated_Code/AdcLdd1.c **** **              Volt. ref. pin                             : VREFL
  53:../Generated_Code/AdcLdd1.c **** **              Volt. ref pin signal                       : 
  54:../Generated_Code/AdcLdd1.c **** **          Initialization                                 : 
  55:../Generated_Code/AdcLdd1.c **** **            Enabled in init. code                        : yes
  56:../Generated_Code/AdcLdd1.c **** **            Auto initialization                          : no
  57:../Generated_Code/AdcLdd1.c **** **            Event mask                                   : 
  58:../Generated_Code/AdcLdd1.c **** **              OnMeasurementComplete                      : Enabled
  59:../Generated_Code/AdcLdd1.c **** **              OnError                                    : Disabled
  60:../Generated_Code/AdcLdd1.c **** **          CPU clock/configuration selection              : 
  61:../Generated_Code/AdcLdd1.c **** **            Clock configuration 0                        : This component enabled
  62:../Generated_Code/AdcLdd1.c **** **            Clock configuration 1                        : This component disabled
  63:../Generated_Code/AdcLdd1.c **** **            Clock configuration 2                        : This component disabled
  64:../Generated_Code/AdcLdd1.c **** **            Clock configuration 3                        : This component disabled
  65:../Generated_Code/AdcLdd1.c **** **            Clock configuration 4                        : This component disabled
  66:../Generated_Code/AdcLdd1.c **** **            Clock configuration 5                        : This component disabled
  67:../Generated_Code/AdcLdd1.c **** **            Clock configuration 6                        : This component disabled
  68:../Generated_Code/AdcLdd1.c **** **            Clock configuration 7                        : This component disabled
  69:../Generated_Code/AdcLdd1.c **** **     Contents    :
  70:../Generated_Code/AdcLdd1.c **** **         Init                         - LDD_TDeviceData* AdcLdd1_Init(LDD_TUserData *UserDataPtr)
  71:../Generated_Code/AdcLdd1.c **** **         StartSingleMeasurement       - LDD_TError AdcLdd1_StartSingleMeasurement(LDD_TDeviceData
  72:../Generated_Code/AdcLdd1.c **** **         CancelMeasurement            - LDD_TError AdcLdd1_CancelMeasurement(LDD_TDeviceData *Dev
  73:../Generated_Code/AdcLdd1.c **** **         GetMeasuredValues            - LDD_TError AdcLdd1_GetMeasuredValues(LDD_TDeviceData *Dev
  74:../Generated_Code/AdcLdd1.c **** **         CreateSampleGroup            - LDD_TError AdcLdd1_CreateSampleGroup(LDD_TDeviceData *Dev
  75:../Generated_Code/AdcLdd1.c **** **         GetMeasurementCompleteStatus - bool AdcLdd1_GetMeasurementCompleteStatus(LDD_TDeviceData
  76:../Generated_Code/AdcLdd1.c **** **         StartCalibration             - LDD_TError AdcLdd1_StartCalibration(LDD_TDeviceData *Devi
  77:../Generated_Code/AdcLdd1.c **** **         GetCalibrationResultStatus   - LDD_TError AdcLdd1_GetCalibrationResultStatus(LDD_TDevice
  78:../Generated_Code/AdcLdd1.c **** **
  79:../Generated_Code/AdcLdd1.c **** **     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
  80:../Generated_Code/AdcLdd1.c **** **     All Rights Reserved.
  81:../Generated_Code/AdcLdd1.c **** **     
  82:../Generated_Code/AdcLdd1.c **** **     Redistribution and use in source and binary forms, with or without modification,
  83:../Generated_Code/AdcLdd1.c **** **     are permitted provided that the following conditions are met:
  84:../Generated_Code/AdcLdd1.c **** **     
  85:../Generated_Code/AdcLdd1.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  86:../Generated_Code/AdcLdd1.c **** **       of conditions and the following disclaimer.
  87:../Generated_Code/AdcLdd1.c **** **     
  88:../Generated_Code/AdcLdd1.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
  89:../Generated_Code/AdcLdd1.c **** **       list of conditions and the following disclaimer in the documentation and/or
  90:../Generated_Code/AdcLdd1.c **** **       other materials provided with the distribution.
  91:../Generated_Code/AdcLdd1.c **** **     
  92:../Generated_Code/AdcLdd1.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  93:../Generated_Code/AdcLdd1.c **** **       contributors may be used to endorse or promote products derived from this
  94:../Generated_Code/AdcLdd1.c **** **       software without specific prior written permission.
  95:../Generated_Code/AdcLdd1.c **** **     
  96:../Generated_Code/AdcLdd1.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  97:../Generated_Code/AdcLdd1.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  98:../Generated_Code/AdcLdd1.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  99:../Generated_Code/AdcLdd1.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 100:../Generated_Code/AdcLdd1.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 101:../Generated_Code/AdcLdd1.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 102:../Generated_Code/AdcLdd1.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 103:../Generated_Code/AdcLdd1.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 104:../Generated_Code/AdcLdd1.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 105:../Generated_Code/AdcLdd1.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 106:../Generated_Code/AdcLdd1.c **** **     
 107:../Generated_Code/AdcLdd1.c **** **     http: www.freescale.com
 108:../Generated_Code/AdcLdd1.c **** **     mail: support@freescale.com
 109:../Generated_Code/AdcLdd1.c **** ** ###################################################################*/
 110:../Generated_Code/AdcLdd1.c **** /*!
 111:../Generated_Code/AdcLdd1.c **** ** @file AdcLdd1.c
 112:../Generated_Code/AdcLdd1.c **** ** @version 01.08
 113:../Generated_Code/AdcLdd1.c **** ** @brief
 114:../Generated_Code/AdcLdd1.c **** **         This device "ADC_LDD" implements an A/D converter,
 115:../Generated_Code/AdcLdd1.c **** **         its control methods and interrupt/event handling procedure.
 116:../Generated_Code/AdcLdd1.c **** */         
 117:../Generated_Code/AdcLdd1.c **** /*!
 118:../Generated_Code/AdcLdd1.c **** **  @addtogroup AdcLdd1_module AdcLdd1 module documentation
 119:../Generated_Code/AdcLdd1.c **** **  @{
 120:../Generated_Code/AdcLdd1.c **** */         
 121:../Generated_Code/AdcLdd1.c **** 
 122:../Generated_Code/AdcLdd1.c **** /* MODULE AdcLdd1. */
 123:../Generated_Code/AdcLdd1.c **** 
 124:../Generated_Code/AdcLdd1.c **** #include "AD1.h"
 125:../Generated_Code/AdcLdd1.c **** #include "AdcLdd1.h"
 126:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} No RTOS includes */
 127:../Generated_Code/AdcLdd1.c **** 
 128:../Generated_Code/AdcLdd1.c **** #ifdef __cplusplus
 129:../Generated_Code/AdcLdd1.c **** extern "C" { 
 130:../Generated_Code/AdcLdd1.c **** #endif
 131:../Generated_Code/AdcLdd1.c **** 
 132:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_CHANNEL0_31_PIN_MASK (LDD_ADC_CHANNEL_0_PIN | LDD_ADC_CHANNEL_1_PIN) /*!<
 133:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_CHANNEL32_63_PIN_MASK 0x00U /*!< Mask of all allocated channel pins from 
 134:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_TRIGGER_PIN_MASK 0x00U /*!< Mask of all allocated trigger pins */
 135:../Generated_Code/AdcLdd1.c **** #define AdcLdd1_AVAILABLE_VOLT_REF_PIN_MASK (LDD_ADC_LOW_VOLT_REF_PIN | LDD_ADC_HIGH_VOLT_REF_PIN) 
 136:../Generated_Code/AdcLdd1.c **** 
 137:../Generated_Code/AdcLdd1.c **** static const uint8_t ChannelToPin[] = { /* Channel to pin conversion table */
 138:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 139:../Generated_Code/AdcLdd1.c ****   0x40U,                               /* Status and control register value */
 140:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC1A: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 141:../Generated_Code/AdcLdd1.c ****   0x44U                                /* Status and control register value */
 142:../Generated_Code/AdcLdd1.c **** };
 143:../Generated_Code/AdcLdd1.c **** 
 144:../Generated_Code/AdcLdd1.c **** typedef struct {
 145:../Generated_Code/AdcLdd1.c ****   uint8_t SampleCount;                 /* Number of samples in the last selected/created sample gro
 146:../Generated_Code/AdcLdd1.c ****   uint8_t FirstSample;                 /* First sample of group store */
 147:../Generated_Code/AdcLdd1.c ****   uint8_t CompleteStatus;              /* Measurement complete status flag */
 148:../Generated_Code/AdcLdd1.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 149:../Generated_Code/AdcLdd1.c **** } AdcLdd1_TDeviceData;                 /* Device data structure type */
 150:../Generated_Code/AdcLdd1.c **** 
 151:../Generated_Code/AdcLdd1.c **** typedef AdcLdd1_TDeviceData* AdcLdd1_TDeviceDataPtr ; /* Pointer to the device data structure. */
 152:../Generated_Code/AdcLdd1.c **** 
 153:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 154:../Generated_Code/AdcLdd1.c **** static AdcLdd1_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 155:../Generated_Code/AdcLdd1.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 156:../Generated_Code/AdcLdd1.c **** static AdcLdd1_TDeviceDataPtr INT_ADC0__DEFAULT_RTOS_ISRPARAM;
 157:../Generated_Code/AdcLdd1.c **** /*
 158:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 159:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_Init (component ADC_LDD)
 160:../Generated_Code/AdcLdd1.c **** */
 161:../Generated_Code/AdcLdd1.c **** /*!
 162:../Generated_Code/AdcLdd1.c **** **     @brief
 163:../Generated_Code/AdcLdd1.c **** **         Initializes the device. Allocates memory for the device data
 164:../Generated_Code/AdcLdd1.c **** **         structure, allocates interrupt vectors and sets interrupt
 165:../Generated_Code/AdcLdd1.c **** **         priority, sets pin routing, sets timing, etc.
 166:../Generated_Code/AdcLdd1.c **** **         If the "Enable in init. code" is set to "yes" value then the
 167:../Generated_Code/AdcLdd1.c **** **         device is also enabled(see the description of the Enable()
 168:../Generated_Code/AdcLdd1.c **** **         method). In this case the Enable() method is not necessary
 169:../Generated_Code/AdcLdd1.c **** **         and needn't to be generated. 
 170:../Generated_Code/AdcLdd1.c **** **         This method can be called only once. Before the second call
 171:../Generated_Code/AdcLdd1.c **** **         of Init() the Deinit() must be called first.
 172:../Generated_Code/AdcLdd1.c **** **     @param
 173:../Generated_Code/AdcLdd1.c **** **         UserDataPtr     - Pointer to the user or
 174:../Generated_Code/AdcLdd1.c **** **                           RTOS specific data. This pointer will be
 175:../Generated_Code/AdcLdd1.c **** **                           passed as an event or callback parameter.
 176:../Generated_Code/AdcLdd1.c **** **     @return
 177:../Generated_Code/AdcLdd1.c **** **                         - Device data structure pointer.
 178:../Generated_Code/AdcLdd1.c **** */
 179:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 180:../Generated_Code/AdcLdd1.c **** LDD_TDeviceData* AdcLdd1_Init(LDD_TUserData *UserDataPtr)
 181:../Generated_Code/AdcLdd1.c **** {
  45              		.loc 1 181 0
  46              		.cfi_startproc
  47 0000 80B5     		push	{r7, lr}
  48              	.LCFI0:
  49              		.cfi_def_cfa_offset 8
  50              		.cfi_offset 7, -8
  51              		.cfi_offset 14, -4
  52 0002 84B0     		sub	sp, sp, #16
  53              	.LCFI1:
  54              		.cfi_def_cfa_offset 24
  55 0004 00AF     		add	r7, sp, #0
  56              	.LCFI2:
  57              		.cfi_def_cfa_register 7
  58 0006 7860     		str	r0, [r7, #4]
 182:../Generated_Code/AdcLdd1.c ****   /* Allocate LDD device structure */
 183:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv;
 184:../Generated_Code/AdcLdd1.c **** 
 185:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 186:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  59              		.loc 1 186 0
  60 0008 294B     		ldr	r3, .L3
  61 000a FB60     		str	r3, [r7, #12]
 187:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  62              		.loc 1 187 0
  63 000c FB68     		ldr	r3, [r7, #12]
  64 000e 7A68     		ldr	r2, [r7, #4]
  65 0010 5A60     		str	r2, [r3, #4]
 188:../Generated_Code/AdcLdd1.c ****   /* Interrupt vector(s) allocation */
 189:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 190:../Generated_Code/AdcLdd1.c ****   INT_ADC0__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
  66              		.loc 1 190 0
  67 0012 284B     		ldr	r3, .L3+4
  68 0014 FA68     		ldr	r2, [r7, #12]
  69 0016 1A60     		str	r2, [r3]
 191:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->SampleCount = 0U;     /* Initializing SampleCount for right access of some methods
  70              		.loc 1 191 0
  71 0018 FB68     		ldr	r3, [r7, #12]
  72 001a 0022     		mov	r2, #0
  73 001c 1A70     		strb	r2, [r3]
 192:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->CompleteStatus = FALSE; /* Clear measurement complete status flag */
  74              		.loc 1 192 0
  75 001e FB68     		ldr	r3, [r7, #12]
  76 0020 0022     		mov	r2, #0
  77 0022 9A70     		strb	r2, [r3, #2]
 193:../Generated_Code/AdcLdd1.c ****   /* SIM_SCGC6: ADC0=1 */
 194:../Generated_Code/AdcLdd1.c ****   SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;
  78              		.loc 1 194 0
  79 0024 244A     		ldr	r2, .L3+8
  80 0026 2449     		ldr	r1, .L3+8
  81 0028 244B     		ldr	r3, .L3+12
  82 002a CB58     		ldr	r3, [r1, r3]
  83 002c 8021     		mov	r1, #128
  84 002e 0905     		lsl	r1, r1, #20
  85 0030 1943     		orr	r1, r3
  86 0032 224B     		ldr	r3, .L3+12
  87 0034 D150     		str	r1, [r2, r3]
 195:../Generated_Code/AdcLdd1.c ****   /* Interrupt vector(s) priority setting */
 196:../Generated_Code/AdcLdd1.c ****   /* NVIC_IPR3: PRI_15=0x80 */
 197:../Generated_Code/AdcLdd1.c ****   NVIC_IPR3 = (uint32_t)((NVIC_IPR3 & (uint32_t)~(uint32_t)(
  88              		.loc 1 197 0
  89 0036 224A     		ldr	r2, .L3+16
  90 0038 2149     		ldr	r1, .L3+16
  91 003a C323     		mov	r3, #195
  92 003c 9B00     		lsl	r3, r3, #2
  93 003e CB58     		ldr	r3, [r1, r3]
  94 0040 1B02     		lsl	r3, r3, #8
  95 0042 1B0A     		lsr	r3, r3, #8
  96 0044 8021     		mov	r1, #128
  97 0046 0906     		lsl	r1, r1, #24
  98 0048 1943     		orr	r1, r3
  99 004a C323     		mov	r3, #195
 100 004c 9B00     		lsl	r3, r3, #2
 101 004e D150     		str	r1, [r2, r3]
 198:../Generated_Code/AdcLdd1.c ****                NVIC_IP_PRI_15(0x7F)
 199:../Generated_Code/AdcLdd1.c ****               )) | (uint32_t)(
 200:../Generated_Code/AdcLdd1.c ****                NVIC_IP_PRI_15(0x80)
 201:../Generated_Code/AdcLdd1.c ****               ));
 202:../Generated_Code/AdcLdd1.c ****   /* NVIC_ISER: SETENA|=0x8000 */
 203:../Generated_Code/AdcLdd1.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x8000);
 102              		.loc 1 203 0
 103 0050 1B4B     		ldr	r3, .L3+16
 104 0052 1B4A     		ldr	r2, .L3+16
 105 0054 1268     		ldr	r2, [r2]
 106 0056 8021     		mov	r1, #128
 107 0058 0902     		lsl	r1, r1, #8
 108 005a 0A43     		orr	r2, r1
 109 005c 1A60     		str	r2, [r3]
 204:../Generated_Code/AdcLdd1.c ****   /* PORTE_PCR20: ISF=0,MUX=0 */
 205:../Generated_Code/AdcLdd1.c ****   PORTE_PCR20 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
 110              		.loc 1 205 0
 111 005e 194B     		ldr	r3, .L3+20
 112 0060 184A     		ldr	r2, .L3+20
 113 0062 116D     		ldr	r1, [r2, #80]
 114 0064 184A     		ldr	r2, .L3+24
 115 0066 0A40     		and	r2, r1
 116 0068 1A65     		str	r2, [r3, #80]
 206:../Generated_Code/AdcLdd1.c ****   /* PORTE_PCR21: ISF=0,MUX=0 */
 207:../Generated_Code/AdcLdd1.c ****   PORTE_PCR21 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
 117              		.loc 1 207 0
 118 006a 164B     		ldr	r3, .L3+20
 119 006c 154A     		ldr	r2, .L3+20
 120 006e 516D     		ldr	r1, [r2, #84]
 121 0070 154A     		ldr	r2, .L3+24
 122 0072 0A40     		and	r2, r1
 123 0074 5A65     		str	r2, [r3, #84]
 208:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG2: MUXSEL=0 */
 209:../Generated_Code/AdcLdd1.c ****   ADC0_CFG2 &= (uint32_t)~(uint32_t)(ADC_CFG2_MUXSEL_MASK);
 124              		.loc 1 209 0
 125 0076 154B     		ldr	r3, .L3+28
 126 0078 144A     		ldr	r2, .L3+28
 127 007a D268     		ldr	r2, [r2, #12]
 128 007c 1021     		mov	r1, #16
 129 007e 8A43     		bic	r2, r1
 130 0080 DA60     		str	r2, [r3, #12]
 210:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG1: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 211:../Generated_Code/AdcLdd1.c ****   ADC0_CFG1 = ADC_CFG1_ADIV(0x01) |
 131              		.loc 1 211 0
 132 0082 124B     		ldr	r3, .L3+28
 133 0084 2F22     		mov	r2, #47
 134 0086 9A60     		str	r2, [r3, #8]
 212:../Generated_Code/AdcLdd1.c ****               ADC_CFG1_MODE(0x03) |
 213:../Generated_Code/AdcLdd1.c ****               ADC_CFG1_ADICLK(0x03);
 214:../Generated_Code/AdcLdd1.c ****   /* ADC0_CFG2: MUXSEL=0,ADACKEN=0,ADHSC=0,ADLSTS=0 */
 215:../Generated_Code/AdcLdd1.c ****   ADC0_CFG2 &= (uint32_t)~(uint32_t)(
 135              		.loc 1 215 0
 136 0088 104B     		ldr	r3, .L3+28
 137 008a 104A     		ldr	r2, .L3+28
 138 008c D268     		ldr	r2, [r2, #12]
 139 008e 1F21     		mov	r1, #31
 140 0090 8A43     		bic	r2, r1
 141 0092 DA60     		str	r2, [r3, #12]
 216:../Generated_Code/AdcLdd1.c ****                 ADC_CFG2_MUXSEL_MASK |
 217:../Generated_Code/AdcLdd1.c ****                 ADC_CFG2_ADACKEN_MASK |
 218:../Generated_Code/AdcLdd1.c ****                 ADC_CFG2_ADHSC_MASK |
 219:../Generated_Code/AdcLdd1.c ****                 ADC_CFG2_ADLSTS(0x03)
 220:../Generated_Code/AdcLdd1.c ****                );
 221:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC2: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 222:../Generated_Code/AdcLdd1.c ****   ADC0_SC2 = ADC_SC2_REFSEL(0x00);
 142              		.loc 1 222 0
 143 0094 0D4B     		ldr	r3, .L3+28
 144 0096 0022     		mov	r2, #0
 145 0098 1A62     		str	r2, [r3, #32]
 223:../Generated_Code/AdcLdd1.c ****   /* ADC0_SC3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 224:../Generated_Code/AdcLdd1.c ****   ADC0_SC3 = (ADC_SC3_CALF_MASK | ADC_SC3_AVGS(0x00));
 146              		.loc 1 224 0
 147 009a 0C4B     		ldr	r3, .L3+28
 148 009c 4022     		mov	r2, #64
 149 009e 5A62     		str	r2, [r3, #36]
 225:../Generated_Code/AdcLdd1.c ****   /* Registration of the device structure */
 226:../Generated_Code/AdcLdd1.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_AdcLdd1_ID,DeviceDataPrv);
 150              		.loc 1 226 0
 151 00a0 0B4B     		ldr	r3, .L3+32
 152 00a2 FA68     		ldr	r2, [r7, #12]
 153 00a4 9A61     		str	r2, [r3, #24]
 227:../Generated_Code/AdcLdd1.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 154              		.loc 1 227 0
 155 00a6 FB68     		ldr	r3, [r7, #12]
 228:../Generated_Code/AdcLdd1.c **** }
 156              		.loc 1 228 0
 157 00a8 181C     		mov	r0, r3
 158 00aa BD46     		mov	sp, r7
 159 00ac 04B0     		add	sp, sp, #16
 160              		@ sp needed for prologue
 161 00ae 80BD     		pop	{r7, pc}
 162              	.L4:
 163              		.align	2
 164              	.L3:
 165 00b0 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 166 00b4 00000000 		.word	INT_ADC0__DEFAULT_RTOS_ISRPARAM
 167 00b8 00700440 		.word	1074032640
 168 00bc 3C100000 		.word	4156
 169 00c0 00E100E0 		.word	-536813312
 170 00c4 00D00440 		.word	1074057216
 171 00c8 FFF8FFFE 		.word	-16779009
 172 00cc 00B00340 		.word	1073983488
 173 00d0 00000000 		.word	PE_LDD_DeviceDataList
 174              		.cfi_endproc
 175              	.LFE0:
 177              		.section	.text.AdcLdd1_StartSingleMeasurement,"ax",%progbits
 178              		.align	2
 179              		.global	AdcLdd1_StartSingleMeasurement
 180              		.code	16
 181              		.thumb_func
 183              	AdcLdd1_StartSingleMeasurement:
 184              	.LFB1:
 229:../Generated_Code/AdcLdd1.c **** 
 230:../Generated_Code/AdcLdd1.c **** /*
 231:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 232:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_StartSingleMeasurement (component ADC_LDD)
 233:../Generated_Code/AdcLdd1.c **** */
 234:../Generated_Code/AdcLdd1.c **** /*!
 235:../Generated_Code/AdcLdd1.c **** **     @brief
 236:../Generated_Code/AdcLdd1.c **** **         This method starts one measurement of the selected group of
 237:../Generated_Code/AdcLdd1.c **** **         samples and exits immediately. This is ADC SW trigger method.
 238:../Generated_Code/AdcLdd1.c **** **         The group of samples for measurement is specified by
 239:../Generated_Code/AdcLdd1.c **** **         preceding call to [SelectSampleGroup()] or
 240:../Generated_Code/AdcLdd1.c **** **         [CreateSampleGroup] method. 
 241:../Generated_Code/AdcLdd1.c **** **         DMA disabled: The [OnMeasurementComplete() ] event is
 242:../Generated_Code/AdcLdd1.c **** **         invoked after the measurement is done and if the event is
 243:../Generated_Code/AdcLdd1.c **** **         enabled. Results of the measurement can be read by the
 244:../Generated_Code/AdcLdd1.c **** **         [GetMeasuredValues()] method. 
 245:../Generated_Code/AdcLdd1.c **** **         DMA enabled: DMA request from configured ADC is enabled
 246:../Generated_Code/AdcLdd1.c **** **         automatically. The [OnMeasurementComplete() ] event is
 247:../Generated_Code/AdcLdd1.c **** **         invoked after the requested number of results are
 248:../Generated_Code/AdcLdd1.c **** **         transferred to destination buffer by DMA and if the event is
 249:../Generated_Code/AdcLdd1.c **** **         enabled. [GetMeasuredValues()] method is not available if
 250:../Generated_Code/AdcLdd1.c **** **         DMA mode is enabled. If the DMA transfer was completed
 251:../Generated_Code/AdcLdd1.c **** **         before and DMA is not recofingured, DMA error can occur. See
 252:../Generated_Code/AdcLdd1.c **** **         also [SetBuffer()] method. 
 253:../Generated_Code/AdcLdd1.c **** **         The state of the measurement can be also polled by the
 254:../Generated_Code/AdcLdd1.c **** **         [GetMeasurementCompleteStatus()] method. The [Discontinuous
 255:../Generated_Code/AdcLdd1.c **** **         mode] doesn't support this method.
 256:../Generated_Code/AdcLdd1.c **** **     @param
 257:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 258:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 259:../Generated_Code/AdcLdd1.c **** **     @return
 260:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 261:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 262:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 263:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 264:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 265:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - A measurement is in progress 
 266:../Generated_Code/AdcLdd1.c **** */
 267:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 268:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr)
 269:../Generated_Code/AdcLdd1.c **** {
 185              		.loc 1 269 0
 186              		.cfi_startproc
 187 0000 80B5     		push	{r7, lr}
 188              	.LCFI3:
 189              		.cfi_def_cfa_offset 8
 190              		.cfi_offset 7, -8
 191              		.cfi_offset 14, -4
 192 0002 82B0     		sub	sp, sp, #8
 193              	.LCFI4:
 194              		.cfi_def_cfa_offset 16
 195 0004 00AF     		add	r7, sp, #0
 196              	.LCFI5:
 197              		.cfi_def_cfa_register 7
 198 0006 7860     		str	r0, [r7, #4]
 270:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 271:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U) { /* Last measurement still pending? */
 199              		.loc 1 271 0
 200 0008 0D4B     		ldr	r3, .L8
 201 000a 1A6A     		ldr	r2, [r3, #32]
 202 000c 8023     		mov	r3, #128
 203 000e 1340     		and	r3, r2
 204 0010 01D0     		beq	.L6
 272:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 205              		.loc 1 272 0
 206 0012 0823     		mov	r3, #8
 207 0014 10E0     		b	.L7
 208              	.L6:
 273:../Generated_Code/AdcLdd1.c ****   }
 274:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetContinuousMode(ADC0_BASE_PTR, ADC_PDD_ONE_CONVERSION); /* Set one conversion mode */
 209              		.loc 1 274 0
 210 0016 0A4B     		ldr	r3, .L8
 211 0018 094A     		ldr	r2, .L8
 212 001a 526A     		ldr	r2, [r2, #36]
 213 001c 0821     		mov	r1, #8
 214 001e 8A43     		bic	r2, r1
 215 0020 5A62     		str	r2, [r3, #36]
 275:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 216              		.loc 1 275 0
 217 0022 074B     		ldr	r3, .L8
 218 0024 064A     		ldr	r2, .L8
 219 0026 126A     		ldr	r2, [r2, #32]
 220 0028 4021     		mov	r1, #64
 221 002a 8A43     		bic	r2, r1
 222 002c 1A62     		str	r2, [r3, #32]
 276:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->FirstS
 223              		.loc 1 276 0
 224 002e 044B     		ldr	r3, .L8
 225 0030 7A68     		ldr	r2, [r7, #4]
 226 0032 5278     		ldrb	r2, [r2, #1]
 227 0034 1A60     		str	r2, [r3]
 277:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 228              		.loc 1 277 0
 229 0036 0023     		mov	r3, #0
 230              	.L7:
 278:../Generated_Code/AdcLdd1.c **** }
 231              		.loc 1 278 0
 232 0038 181C     		mov	r0, r3
 233 003a BD46     		mov	sp, r7
 234 003c 02B0     		add	sp, sp, #8
 235              		@ sp needed for prologue
 236 003e 80BD     		pop	{r7, pc}
 237              	.L9:
 238              		.align	2
 239              	.L8:
 240 0040 00B00340 		.word	1073983488
 241              		.cfi_endproc
 242              	.LFE1:
 244              		.section	.text.AdcLdd1_CancelMeasurement,"ax",%progbits
 245              		.align	2
 246              		.global	AdcLdd1_CancelMeasurement
 247              		.code	16
 248              		.thumb_func
 250              	AdcLdd1_CancelMeasurement:
 251              	.LFB2:
 279:../Generated_Code/AdcLdd1.c **** 
 280:../Generated_Code/AdcLdd1.c **** /*
 281:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 282:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_CancelMeasurement (component ADC_LDD)
 283:../Generated_Code/AdcLdd1.c **** */
 284:../Generated_Code/AdcLdd1.c **** /*!
 285:../Generated_Code/AdcLdd1.c **** **     @brief
 286:../Generated_Code/AdcLdd1.c **** **         This method cancels the measurement in progress. Typically
 287:../Generated_Code/AdcLdd1.c **** **         the OnMeasurementComplete() event is not invoked for
 288:../Generated_Code/AdcLdd1.c **** **         cancelled measurement. If DMA mode is enabled, DMA request
 289:../Generated_Code/AdcLdd1.c **** **         from ADC is disabled and DMA transfer is cancelled. 
 290:../Generated_Code/AdcLdd1.c **** **     @param
 291:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 292:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 293:../Generated_Code/AdcLdd1.c **** **     @return
 294:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 295:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 296:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 297:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 298:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 299:../Generated_Code/AdcLdd1.c **** */
 300:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 301:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_CancelMeasurement(LDD_TDeviceData *DeviceDataPtr)
 302:../Generated_Code/AdcLdd1.c **** {
 252              		.loc 1 302 0
 253              		.cfi_startproc
 254 0000 80B5     		push	{r7, lr}
 255              	.LCFI6:
 256              		.cfi_def_cfa_offset 8
 257              		.cfi_offset 7, -8
 258              		.cfi_offset 14, -4
 259 0002 82B0     		sub	sp, sp, #8
 260              	.LCFI7:
 261              		.cfi_def_cfa_offset 16
 262 0004 00AF     		add	r7, sp, #0
 263              	.LCFI8:
 264              		.cfi_def_cfa_register 7
 265 0006 7860     		str	r0, [r7, #4]
 303:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 304:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 266              		.loc 1 304 0
 267 0008 064B     		ldr	r3, .L12
 268 000a 064A     		ldr	r2, .L12
 269 000c 126A     		ldr	r2, [r2, #32]
 270 000e 4021     		mov	r1, #64
 271 0010 8A43     		bic	r2, r1
 272 0012 1A62     		str	r2, [r3, #32]
 305:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, 0x1FU); /* Disable device - A */
 273              		.loc 1 305 0
 274 0014 034B     		ldr	r3, .L12
 275 0016 1F22     		mov	r2, #31
 276 0018 1A60     		str	r2, [r3]
 306:../Generated_Code/AdcLdd1.c ****   
 307:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* If yes then set the flag "device enabled" */  
 277              		.loc 1 307 0
 278 001a 0023     		mov	r3, #0
 308:../Generated_Code/AdcLdd1.c **** }
 279              		.loc 1 308 0
 280 001c 181C     		mov	r0, r3
 281 001e BD46     		mov	sp, r7
 282 0020 02B0     		add	sp, sp, #8
 283              		@ sp needed for prologue
 284 0022 80BD     		pop	{r7, pc}
 285              	.L13:
 286              		.align	2
 287              	.L12:
 288 0024 00B00340 		.word	1073983488
 289              		.cfi_endproc
 290              	.LFE2:
 292              		.section	.text.AdcLdd1_CreateSampleGroup,"ax",%progbits
 293              		.align	2
 294              		.global	AdcLdd1_CreateSampleGroup
 295              		.code	16
 296              		.thumb_func
 298              	AdcLdd1_CreateSampleGroup:
 299              	.LFB3:
 309:../Generated_Code/AdcLdd1.c **** 
 310:../Generated_Code/AdcLdd1.c **** /*
 311:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 312:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_CreateSampleGroup (component ADC_LDD)
 313:../Generated_Code/AdcLdd1.c **** */
 314:../Generated_Code/AdcLdd1.c **** /*!
 315:../Generated_Code/AdcLdd1.c **** **     @brief
 316:../Generated_Code/AdcLdd1.c **** **         This method prepares HW for next measurement according to
 317:../Generated_Code/AdcLdd1.c **** **         array of samples defined during run-time. The array of
 318:../Generated_Code/AdcLdd1.c **** **         samples should be prepared prior to calling this method.
 319:../Generated_Code/AdcLdd1.c **** **         Pointer to the array is passed into this method in parameter
 320:../Generated_Code/AdcLdd1.c **** **         SampleGroupPtr. The number of samples is defined by
 321:../Generated_Code/AdcLdd1.c **** **         parameter SampleCount. Once any group is prepared, the
 322:../Generated_Code/AdcLdd1.c **** **         measurement can be started multiple times. Note: This method
 323:../Generated_Code/AdcLdd1.c **** **         works only with the sample groups defined during run-time.
 324:../Generated_Code/AdcLdd1.c **** **         For design-time defined groups use [SelectSampleGroup()]
 325:../Generated_Code/AdcLdd1.c **** **         method.
 326:../Generated_Code/AdcLdd1.c **** **     @param
 327:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 328:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 329:../Generated_Code/AdcLdd1.c **** **     @param
 330:../Generated_Code/AdcLdd1.c **** **         SampleGroupPtr  - Pointer to the
 331:../Generated_Code/AdcLdd1.c **** **                           sample definition array. This array can be
 332:../Generated_Code/AdcLdd1.c **** **                           released as soon as the method ends.
 333:../Generated_Code/AdcLdd1.c **** **     @param
 334:../Generated_Code/AdcLdd1.c **** **         SampleCount     - Number of items in the
 335:../Generated_Code/AdcLdd1.c **** **                           sample definition array. Must be less than
 336:../Generated_Code/AdcLdd1.c **** **                           or equal to
 337:../Generated_Code/AdcLdd1.c **** **                           ComponentName_MAX_HW_SAMPLE_COUNT.
 338:../Generated_Code/AdcLdd1.c **** **     @return
 339:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 340:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 341:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 342:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 343:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 344:../Generated_Code/AdcLdd1.c **** **                           ERR_PARAM_INDEX - Channel index in
 345:../Generated_Code/AdcLdd1.c **** **                           SampleGroup structure is out of range
 346:../Generated_Code/AdcLdd1.c **** **                           ERR_PARAM_SAMPLE_COUNT - SampleCount
 347:../Generated_Code/AdcLdd1.c **** **                           variable value is out of range
 348:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - Measurement is in progress 
 349:../Generated_Code/AdcLdd1.c **** */
 350:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 351:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_CreateSampleGroup(LDD_TDeviceData *DeviceDataPtr, LDD_ADC_TSample *SampleGroupPt
 352:../Generated_Code/AdcLdd1.c **** {
 300              		.loc 1 352 0
 301              		.cfi_startproc
 302 0000 80B5     		push	{r7, lr}
 303              	.LCFI9:
 304              		.cfi_def_cfa_offset 8
 305              		.cfi_offset 7, -8
 306              		.cfi_offset 14, -4
 307 0002 86B0     		sub	sp, sp, #24
 308              	.LCFI10:
 309              		.cfi_def_cfa_offset 32
 310 0004 00AF     		add	r7, sp, #0
 311              	.LCFI11:
 312              		.cfi_def_cfa_register 7
 313 0006 F860     		str	r0, [r7, #12]
 314 0008 B960     		str	r1, [r7, #8]
 315 000a FB1D     		add	r3, r7, #7
 316 000c 1A70     		strb	r2, [r3]
 353:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv = (AdcLdd1_TDeviceDataPtr)DeviceDataPtr;
 317              		.loc 1 353 0
 318 000e FB68     		ldr	r3, [r7, #12]
 319 0010 7B61     		str	r3, [r7, #20]
 354:../Generated_Code/AdcLdd1.c **** 
 355:../Generated_Code/AdcLdd1.c ****   /* Sample count test - this test can be disabled by setting the "Ignore range checking"
 356:../Generated_Code/AdcLdd1.c ****      property to the "yes" value in the "Configuration inspector" */
 357:../Generated_Code/AdcLdd1.c ****   if ((SampleCount > AdcLdd1_MAX_HW_SAMPLE_COUNT) || (SampleCount == 0U)) { /* Is number of sample 
 320              		.loc 1 357 0
 321 0012 FB1D     		add	r3, r7, #7
 322 0014 1B78     		ldrb	r3, [r3]
 323 0016 012B     		cmp	r3, #1
 324 0018 03D8     		bhi	.L15
 325              		.loc 1 357 0 is_stmt 0
 326 001a FB1D     		add	r3, r7, #7
 327 001c 1B78     		ldrb	r3, [r3]
 328 001e 002B     		cmp	r3, #0
 329 0020 01D1     		bne	.L16
 330              	.L15:
 358:../Generated_Code/AdcLdd1.c ****     return ERR_PARAM_SAMPLE_COUNT;     /* Yes, return ERR_PARAM_SAMPLE_COUNT */
 331              		.loc 1 358 0 is_stmt 1
 332 0022 9623     		mov	r3, #150
 333 0024 1AE0     		b	.L17
 334              	.L16:
 359:../Generated_Code/AdcLdd1.c ****   }
 360:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U) { /* Last measurement still pending? */
 335              		.loc 1 360 0
 336 0026 0F4B     		ldr	r3, .L20
 337 0028 1A6A     		ldr	r2, [r3, #32]
 338 002a 8023     		mov	r3, #128
 339 002c 1340     		and	r3, r2
 340 002e 01D0     		beq	.L18
 361:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 341              		.loc 1 361 0
 342 0030 0823     		mov	r3, #8
 343 0032 13E0     		b	.L17
 344              	.L18:
 362:../Generated_Code/AdcLdd1.c ****   }
 363:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->SampleCount = SampleCount; /* Remember sample count */
 345              		.loc 1 363 0
 346 0034 7B69     		ldr	r3, [r7, #20]
 347 0036 FA1D     		add	r2, r7, #7
 348 0038 1278     		ldrb	r2, [r2]
 349 003a 1A70     		strb	r2, [r3]
 364:../Generated_Code/AdcLdd1.c ****   /* Channel index test - this test can be disabled by setting the "Ignore range checking"
 365:../Generated_Code/AdcLdd1.c ****      property to the "yes" value in the "Configuration inspector" */
 366:../Generated_Code/AdcLdd1.c ****   if (SampleGroupPtr[0].ChannelIdx >= AdcLdd1_CHANNEL_COUNT) { /* Is channel index out of range? */
 350              		.loc 1 366 0
 351 003c BB68     		ldr	r3, [r7, #8]
 352 003e 1B78     		ldrb	r3, [r3]
 353 0040 012B     		cmp	r3, #1
 354 0042 01D9     		bls	.L19
 367:../Generated_Code/AdcLdd1.c ****     return ERR_PARAM_INDEX;            /* Yes, return ERR_PARAM_INDEX */
 355              		.loc 1 367 0
 356 0044 8223     		mov	r3, #130
 357 0046 09E0     		b	.L17
 358              	.L19:
 368:../Generated_Code/AdcLdd1.c ****   }
 369:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->FirstSample = (ChannelToPin[SampleGroupPtr[0].ChannelIdx]) | (uint8_t)(LDD_ADC_ON_
 359              		.loc 1 369 0
 360 0048 BB68     		ldr	r3, [r7, #8]
 361 004a 1B78     		ldrb	r3, [r3]
 362 004c 064A     		ldr	r2, .L20+4
 363 004e D35C     		ldrb	r3, [r2, r3]
 364 0050 4022     		mov	r2, #64
 365 0052 1343     		orr	r3, r2
 366 0054 DAB2     		uxtb	r2, r3
 367 0056 7B69     		ldr	r3, [r7, #20]
 368 0058 5A70     		strb	r2, [r3, #1]
 370:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 369              		.loc 1 370 0
 370 005a 0023     		mov	r3, #0
 371              	.L17:
 371:../Generated_Code/AdcLdd1.c **** }
 372              		.loc 1 371 0
 373 005c 181C     		mov	r0, r3
 374 005e BD46     		mov	sp, r7
 375 0060 06B0     		add	sp, sp, #24
 376              		@ sp needed for prologue
 377 0062 80BD     		pop	{r7, pc}
 378              	.L21:
 379              		.align	2
 380              	.L20:
 381 0064 00B00340 		.word	1073983488
 382 0068 00000000 		.word	ChannelToPin
 383              		.cfi_endproc
 384              	.LFE3:
 386              		.section	.text.AdcLdd1_GetMeasuredValues,"ax",%progbits
 387              		.align	2
 388              		.global	AdcLdd1_GetMeasuredValues
 389              		.code	16
 390              		.thumb_func
 392              	AdcLdd1_GetMeasuredValues:
 393              	.LFB4:
 372:../Generated_Code/AdcLdd1.c **** 
 373:../Generated_Code/AdcLdd1.c **** /*
 374:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 375:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetMeasuredValues (component ADC_LDD)
 376:../Generated_Code/AdcLdd1.c **** */
 377:../Generated_Code/AdcLdd1.c **** /*!
 378:../Generated_Code/AdcLdd1.c **** **     @brief
 379:../Generated_Code/AdcLdd1.c **** **         This method copies results of the last measurement to the
 380:../Generated_Code/AdcLdd1.c **** **         user supplied buffer. Data size depends on the size of
 381:../Generated_Code/AdcLdd1.c **** **         measured sample group (see [SelectSampleGroup()] or
 382:../Generated_Code/AdcLdd1.c **** **         [CreateSampleGroup()] method). Data representation is
 383:../Generated_Code/AdcLdd1.c **** **         defined by the [Result type] property. Typically this method
 384:../Generated_Code/AdcLdd1.c **** **         is called from [OnMeasurementComplete] event to get results
 385:../Generated_Code/AdcLdd1.c **** **         of the last measurement. This method is not available if DMA
 386:../Generated_Code/AdcLdd1.c **** **         is enabled.
 387:../Generated_Code/AdcLdd1.c **** **     @param
 388:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 389:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 390:../Generated_Code/AdcLdd1.c **** **     @param
 391:../Generated_Code/AdcLdd1.c **** **         BufferPtr       - Pointer to the start of the
 392:../Generated_Code/AdcLdd1.c **** **                           buffer for new results. Count of stored
 393:../Generated_Code/AdcLdd1.c **** **                           measured values equals to the count of the
 394:../Generated_Code/AdcLdd1.c **** **                           samples in the active sample group. It is
 395:../Generated_Code/AdcLdd1.c **** **                           in the user responsibility to provide
 396:../Generated_Code/AdcLdd1.c **** **                           buffer with appropriate size.
 397:../Generated_Code/AdcLdd1.c **** **     @return
 398:../Generated_Code/AdcLdd1.c **** **                         - Error code, possible codes:
 399:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 400:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 401:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 402:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 403:../Generated_Code/AdcLdd1.c **** */
 404:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 405:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr)
 406:../Generated_Code/AdcLdd1.c **** {
 394              		.loc 1 406 0
 395              		.cfi_startproc
 396 0000 80B5     		push	{r7, lr}
 397              	.LCFI12:
 398              		.cfi_def_cfa_offset 8
 399              		.cfi_offset 7, -8
 400              		.cfi_offset 14, -4
 401 0002 84B0     		sub	sp, sp, #16
 402              	.LCFI13:
 403              		.cfi_def_cfa_offset 24
 404 0004 00AF     		add	r7, sp, #0
 405              	.LCFI14:
 406              		.cfi_def_cfa_register 7
 407 0006 7860     		str	r0, [r7, #4]
 408 0008 3960     		str	r1, [r7]
 407:../Generated_Code/AdcLdd1.c ****   uint8_t Sample;
 408:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TResultData *pBuffer = (AdcLdd1_TResultData *)BufferPtr;
 409              		.loc 1 408 0
 410 000a 3B68     		ldr	r3, [r7]
 411 000c BB60     		str	r3, [r7, #8]
 409:../Generated_Code/AdcLdd1.c **** 
 410:../Generated_Code/AdcLdd1.c ****   /* Copy values from result registers defined in the active sample
 411:../Generated_Code/AdcLdd1.c ****      group to the user supplied buffer */
 412:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 412              		.loc 1 412 0
 413 000e 3B1C     		mov	r3, r7
 414 0010 0F33     		add	r3, r3, #15
 415 0012 0022     		mov	r2, #0
 416 0014 1A70     		strb	r2, [r3]
 417 0016 15E0     		b	.L23
 418              	.L24:
 413:../Generated_Code/AdcLdd1.c ****     pBuffer[Sample] =(uint16_t)(ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, Sample));
 419              		.loc 1 413 0
 420 0018 3B1C     		mov	r3, r7
 421 001a 0F33     		add	r3, r3, #15
 422 001c 1B78     		ldrb	r3, [r3]
 423 001e 5B00     		lsl	r3, r3, #1
 424 0020 BA68     		ldr	r2, [r7, #8]
 425 0022 D318     		add	r3, r2, r3
 426 0024 0D4A     		ldr	r2, .L26
 427 0026 391C     		mov	r1, r7
 428 0028 0F31     		add	r1, r1, #15
 429 002a 0978     		ldrb	r1, [r1]
 430 002c 0431     		add	r1, r1, #4
 431 002e 8900     		lsl	r1, r1, #2
 432 0030 8A58     		ldr	r2, [r1, r2]
 433 0032 92B2     		uxth	r2, r2
 434 0034 1A80     		strh	r2, [r3]
 412:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 435              		.loc 1 412 0
 436 0036 3B1C     		mov	r3, r7
 437 0038 0F33     		add	r3, r3, #15
 438 003a 3A1C     		mov	r2, r7
 439 003c 0F32     		add	r2, r2, #15
 440 003e 1278     		ldrb	r2, [r2]
 441 0040 0132     		add	r2, r2, #1
 442 0042 1A70     		strb	r2, [r3]
 443              	.L23:
 412:../Generated_Code/AdcLdd1.c ****   for (Sample = 0U; Sample < ((AdcLdd1_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 444              		.loc 1 412 0 is_stmt 0
 445 0044 7B68     		ldr	r3, [r7, #4]
 446 0046 1B78     		ldrb	r3, [r3]
 447 0048 3A1C     		mov	r2, r7
 448 004a 0F32     		add	r2, r2, #15
 449 004c 1278     		ldrb	r2, [r2]
 450 004e 9A42     		cmp	r2, r3
 451 0050 E2D3     		bcc	.L24
 414:../Generated_Code/AdcLdd1.c ****   }
 415:../Generated_Code/AdcLdd1.c ****   return ERR_OK;                       /* OK */
 452              		.loc 1 415 0 is_stmt 1
 453 0052 0023     		mov	r3, #0
 416:../Generated_Code/AdcLdd1.c **** }
 454              		.loc 1 416 0
 455 0054 181C     		mov	r0, r3
 456 0056 BD46     		mov	sp, r7
 457 0058 04B0     		add	sp, sp, #16
 458              		@ sp needed for prologue
 459 005a 80BD     		pop	{r7, pc}
 460              	.L27:
 461              		.align	2
 462              	.L26:
 463 005c 00B00340 		.word	1073983488
 464              		.cfi_endproc
 465              	.LFE4:
 467              		.section	.text.AdcLdd1_GetMeasurementCompleteStatus,"ax",%progbits
 468              		.align	2
 469              		.global	AdcLdd1_GetMeasurementCompleteStatus
 470              		.code	16
 471              		.thumb_func
 473              	AdcLdd1_GetMeasurementCompleteStatus:
 474              	.LFB5:
 417:../Generated_Code/AdcLdd1.c **** 
 418:../Generated_Code/AdcLdd1.c **** /*
 419:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 420:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetMeasurementCompleteStatus (component ADC_LDD)
 421:../Generated_Code/AdcLdd1.c **** */
 422:../Generated_Code/AdcLdd1.c **** /*!
 423:../Generated_Code/AdcLdd1.c **** **     @brief
 424:../Generated_Code/AdcLdd1.c **** **         Returns whether the measurement is done and the results can
 425:../Generated_Code/AdcLdd1.c **** **         be read by the user. It can be used to poll the state of
 426:../Generated_Code/AdcLdd1.c **** **         measurement if [Interrupt service/event] is disabled or if
 427:../Generated_Code/AdcLdd1.c **** **         [OnMeasurementComplete] event is disabled by the
 428:../Generated_Code/AdcLdd1.c **** **         [SetEventMask()] methods.
 429:../Generated_Code/AdcLdd1.c **** **     @param
 430:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 431:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 432:../Generated_Code/AdcLdd1.c **** **     @return
 433:../Generated_Code/AdcLdd1.c **** **                         - Error code
 434:../Generated_Code/AdcLdd1.c **** **                           true - Measurement is done
 435:../Generated_Code/AdcLdd1.c **** **                           false - Measurement is in progress
 436:../Generated_Code/AdcLdd1.c **** */
 437:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 438:../Generated_Code/AdcLdd1.c **** bool AdcLdd1_GetMeasurementCompleteStatus(LDD_TDeviceData *DeviceDataPtr)
 439:../Generated_Code/AdcLdd1.c **** {
 475              		.loc 1 439 0
 476              		.cfi_startproc
 477 0000 80B5     		push	{r7, lr}
 478              	.LCFI15:
 479              		.cfi_def_cfa_offset 8
 480              		.cfi_offset 7, -8
 481              		.cfi_offset 14, -4
 482 0002 84B0     		sub	sp, sp, #16
 483              	.LCFI16:
 484              		.cfi_def_cfa_offset 24
 485 0004 00AF     		add	r7, sp, #0
 486              	.LCFI17:
 487              		.cfi_def_cfa_register 7
 488 0006 7860     		str	r0, [r7, #4]
 440:../Generated_Code/AdcLdd1.c ****   uint8_t Status;
 441:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv = (AdcLdd1_TDeviceDataPtr)DeviceDataPtr;
 489              		.loc 1 441 0
 490 0008 7B68     		ldr	r3, [r7, #4]
 491 000a FB60     		str	r3, [r7, #12]
 492              	.LBB2:
 442:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 443:../Generated_Code/AdcLdd1.c ****   EnterCritical();
 493              		.loc 1 443 0
 494 000c 3B1C     		mov	r3, r7
 495 000e 0A33     		add	r3, r3, #10
 496              	@ 443 "../Generated_Code/AdcLdd1.c" 1
 497 0010 EFF31080 		MRS R0, PRIMASK
 498 0014 72B6     		CPSID i
 499 0016 1870     		STRB R0, [r3]
 500              	@ 0 "" 2
 501              		.code	16
 502 0018 184B     		ldr	r3, .L34
 503 001a 1B78     		ldrb	r3, [r3]
 504 001c DBB2     		uxtb	r3, r3
 505 001e 0133     		add	r3, r3, #1
 506 0020 DBB2     		uxtb	r3, r3
 507 0022 164A     		ldr	r2, .L34
 508 0024 191C     		add	r1, r3, #0
 509 0026 1170     		strb	r1, [r2]
 510 0028 012B     		cmp	r3, #1
 511 002a 04D1     		bne	.L29
 512              		.loc 1 443 0 is_stmt 0
 513 002c 3B1C     		mov	r3, r7
 514 002e 0A33     		add	r3, r3, #10
 515 0030 1A78     		ldrb	r2, [r3]
 516 0032 134B     		ldr	r3, .L34+4
 517 0034 1A70     		strb	r2, [r3]
 518              	.L29:
 519              	.LBE2:
 444:../Generated_Code/AdcLdd1.c ****   Status = DeviceDataPrv->CompleteStatus; /* Save flag for return */
 520              		.loc 1 444 0 is_stmt 1
 521 0036 3B1C     		mov	r3, r7
 522 0038 0B33     		add	r3, r3, #11
 523 003a FA68     		ldr	r2, [r7, #12]
 524 003c 9278     		ldrb	r2, [r2, #2]
 525 003e 1A70     		strb	r2, [r3]
 445:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->CompleteStatus = FALSE; /* Clear measurement complete status flag */
 526              		.loc 1 445 0
 527 0040 FB68     		ldr	r3, [r7, #12]
 528 0042 0022     		mov	r2, #0
 529 0044 9A70     		strb	r2, [r3, #2]
 446:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 447:../Generated_Code/AdcLdd1.c ****   ExitCritical();
 530              		.loc 1 447 0
 531 0046 0D4B     		ldr	r3, .L34
 532 0048 1B78     		ldrb	r3, [r3]
 533 004a DBB2     		uxtb	r3, r3
 534 004c 013B     		sub	r3, r3, #1
 535 004e DBB2     		uxtb	r3, r3
 536 0050 0A4A     		ldr	r2, .L34
 537 0052 191C     		add	r1, r3, #0
 538 0054 1170     		strb	r1, [r2]
 539 0056 002B     		cmp	r3, #0
 540 0058 03D1     		bne	.L30
 541              		.loc 1 447 0 is_stmt 0
 542 005a 094B     		ldr	r3, .L34+4
 543              	@ 447 "../Generated_Code/AdcLdd1.c" 1
 544 005c 1878     		ldrb r0, [r3]
 545 005e 80F31088 		msr PRIMASK,r0;
 546              		
 547              	@ 0 "" 2
 548              		.code	16
 549              	.L30:
 448:../Generated_Code/AdcLdd1.c ****   return (bool)((Status)? TRUE : FALSE); /* Return saved status */
 550              		.loc 1 448 0 is_stmt 1
 551 0062 3B1C     		mov	r3, r7
 552 0064 0B33     		add	r3, r3, #11
 553 0066 1B78     		ldrb	r3, [r3]
 554 0068 002B     		cmp	r3, #0
 555 006a 01D0     		beq	.L31
 556              		.loc 1 448 0 is_stmt 0
 557 006c 0123     		mov	r3, #1
 558 006e 00E0     		b	.L32
 559              	.L31:
 560              		.loc 1 448 0
 561 0070 0023     		mov	r3, #0
 562              	.L32:
 449:../Generated_Code/AdcLdd1.c **** }
 563              		.loc 1 449 0 is_stmt 1
 564 0072 181C     		mov	r0, r3
 565 0074 BD46     		mov	sp, r7
 566 0076 04B0     		add	sp, sp, #16
 567              		@ sp needed for prologue
 568 0078 80BD     		pop	{r7, pc}
 569              	.L35:
 570 007a C046     		.align	2
 571              	.L34:
 572 007c 00000000 		.word	SR_lock
 573 0080 00000000 		.word	SR_reg
 574              		.cfi_endproc
 575              	.LFE5:
 577              		.section	.text.AdcLdd1_StartCalibration,"ax",%progbits
 578              		.align	2
 579              		.global	AdcLdd1_StartCalibration
 580              		.code	16
 581              		.thumb_func
 583              	AdcLdd1_StartCalibration:
 584              	.LFB6:
 450:../Generated_Code/AdcLdd1.c **** 
 451:../Generated_Code/AdcLdd1.c **** /*
 452:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 453:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_StartCalibration (component ADC_LDD)
 454:../Generated_Code/AdcLdd1.c **** */
 455:../Generated_Code/AdcLdd1.c **** /*!
 456:../Generated_Code/AdcLdd1.c **** **     @brief
 457:../Generated_Code/AdcLdd1.c **** **         This method starts self calibration process. Calibration is
 458:../Generated_Code/AdcLdd1.c **** **         typically used to remove the effects of the gain and offset
 459:../Generated_Code/AdcLdd1.c **** **         from a specific reading.
 460:../Generated_Code/AdcLdd1.c **** **     @param
 461:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 462:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 463:../Generated_Code/AdcLdd1.c **** **     @return
 464:../Generated_Code/AdcLdd1.c **** **                         - Error code
 465:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK
 466:../Generated_Code/AdcLdd1.c **** **                           ERR_SPEED - The device doesn't work in the
 467:../Generated_Code/AdcLdd1.c **** **                           active clock configuration
 468:../Generated_Code/AdcLdd1.c **** **                           ERR_DISABLED - Component is disabled
 469:../Generated_Code/AdcLdd1.c **** **                           ERR_BUSY - A conversion is already running 
 470:../Generated_Code/AdcLdd1.c **** */
 471:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 472:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_StartCalibration(LDD_TDeviceData *DeviceDataPtr)
 473:../Generated_Code/AdcLdd1.c **** {
 585              		.loc 1 473 0
 586              		.cfi_startproc
 587 0000 80B5     		push	{r7, lr}
 588              	.LCFI18:
 589              		.cfi_def_cfa_offset 8
 590              		.cfi_offset 7, -8
 591              		.cfi_offset 14, -4
 592 0002 82B0     		sub	sp, sp, #8
 593              	.LCFI19:
 594              		.cfi_def_cfa_offset 16
 595 0004 00AF     		add	r7, sp, #0
 596              	.LCFI20:
 597              		.cfi_def_cfa_register 7
 598 0006 7860     		str	r0, [r7, #4]
 474:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 475:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U) { /* Last measurement still pending? */
 599              		.loc 1 475 0
 600 0008 0D4B     		ldr	r3, .L39
 601 000a 1A6A     		ldr	r2, [r3, #32]
 602 000c 8023     		mov	r3, #128
 603 000e 1340     		and	r3, r2
 604 0010 01D0     		beq	.L37
 476:../Generated_Code/AdcLdd1.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 605              		.loc 1 476 0
 606 0012 0823     		mov	r3, #8
 607 0014 0FE0     		b	.L38
 608              	.L37:
 477:../Generated_Code/AdcLdd1.c ****   }
 478:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 609              		.loc 1 478 0
 610 0016 0A4B     		ldr	r3, .L39
 611 0018 094A     		ldr	r2, .L39
 612 001a 126A     		ldr	r2, [r2, #32]
 613 001c 4021     		mov	r1, #64
 614 001e 8A43     		bic	r2, r1
 615 0020 1A62     		str	r2, [r3, #32]
 479:../Generated_Code/AdcLdd1.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ADC_PDD_MODULE_DISABLED | ((uint32_t)LDD_ADC_ON
 616              		.loc 1 479 0
 617 0022 074B     		ldr	r3, .L39
 618 0024 5F22     		mov	r2, #95
 619 0026 1A60     		str	r2, [r3]
 480:../Generated_Code/AdcLdd1.c ****   ADC_PDD_StartCalibration(ADC0_BASE_PTR); /* Start calibration */
 620              		.loc 1 480 0
 621 0028 054B     		ldr	r3, .L39
 622 002a 054A     		ldr	r2, .L39
 623 002c 526A     		ldr	r2, [r2, #36]
 624 002e 8021     		mov	r1, #128
 625 0030 0A43     		orr	r2, r1
 626 0032 5A62     		str	r2, [r3, #36]
 481:../Generated_Code/AdcLdd1.c ****   return ERR_OK;
 627              		.loc 1 481 0
 628 0034 0023     		mov	r3, #0
 629              	.L38:
 482:../Generated_Code/AdcLdd1.c **** }
 630              		.loc 1 482 0
 631 0036 181C     		mov	r0, r3
 632 0038 BD46     		mov	sp, r7
 633 003a 02B0     		add	sp, sp, #8
 634              		@ sp needed for prologue
 635 003c 80BD     		pop	{r7, pc}
 636              	.L40:
 637 003e C046     		.align	2
 638              	.L39:
 639 0040 00B00340 		.word	1073983488
 640              		.cfi_endproc
 641              	.LFE6:
 643              		.section	.text.AdcLdd1_GetCalibrationResultStatus,"ax",%progbits
 644              		.align	2
 645              		.global	AdcLdd1_GetCalibrationResultStatus
 646              		.code	16
 647              		.thumb_func
 649              	AdcLdd1_GetCalibrationResultStatus:
 650              	.LFB7:
 483:../Generated_Code/AdcLdd1.c **** 
 484:../Generated_Code/AdcLdd1.c **** /*
 485:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 486:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_GetCalibrationResultStatus (component ADC_LDD)
 487:../Generated_Code/AdcLdd1.c **** */
 488:../Generated_Code/AdcLdd1.c **** /*!
 489:../Generated_Code/AdcLdd1.c **** **     @brief
 490:../Generated_Code/AdcLdd1.c **** **         This method should be used for check the last calibration
 491:../Generated_Code/AdcLdd1.c **** **         result. If calibration completed normally the method finish
 492:../Generated_Code/AdcLdd1.c **** **         calibration process by writing gain calibration values.
 493:../Generated_Code/AdcLdd1.c **** **     @param
 494:../Generated_Code/AdcLdd1.c **** **         DeviceDataPtr   - Device data structure
 495:../Generated_Code/AdcLdd1.c **** **                           pointer returned by [Init] method.
 496:../Generated_Code/AdcLdd1.c **** **     @return
 497:../Generated_Code/AdcLdd1.c **** **                         - Error code
 498:../Generated_Code/AdcLdd1.c **** **                           ERR_OK - OK 
 499:../Generated_Code/AdcLdd1.c **** **                           ERR_FAILED - Last calibration hasn't been
 500:../Generated_Code/AdcLdd1.c **** **                           finished correctly
 501:../Generated_Code/AdcLdd1.c **** */
 502:../Generated_Code/AdcLdd1.c **** /* ===================================================================*/
 503:../Generated_Code/AdcLdd1.c **** LDD_TError AdcLdd1_GetCalibrationResultStatus(LDD_TDeviceData *DeviceDataPtr)
 504:../Generated_Code/AdcLdd1.c **** {
 651              		.loc 1 504 0
 652              		.cfi_startproc
 653 0000 80B5     		push	{r7, lr}
 654              	.LCFI21:
 655              		.cfi_def_cfa_offset 8
 656              		.cfi_offset 7, -8
 657              		.cfi_offset 14, -4
 658 0002 84B0     		sub	sp, sp, #16
 659              	.LCFI22:
 660              		.cfi_def_cfa_offset 24
 661 0004 00AF     		add	r7, sp, #0
 662              	.LCFI23:
 663              		.cfi_def_cfa_register 7
 664 0006 7860     		str	r0, [r7, #4]
 505:../Generated_Code/AdcLdd1.c ****   uint32_t GainValue;
 506:../Generated_Code/AdcLdd1.c **** 
 507:../Generated_Code/AdcLdd1.c ****   (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning *
 508:../Generated_Code/AdcLdd1.c ****   if (ADC_PDD_GetCalibrationFailedStatusFlag(ADC0_BASE_PTR)) {
 665              		.loc 1 508 0
 666 0008 2A4B     		ldr	r3, .L44
 667 000a 5A6A     		ldr	r2, [r3, #36]
 668 000c 4023     		mov	r3, #64
 669 000e 1340     		and	r3, r2
 670 0010 01D0     		beq	.L42
 509:../Generated_Code/AdcLdd1.c ****     return ERR_FAILED;
 671              		.loc 1 509 0
 672 0012 1B23     		mov	r3, #27
 673 0014 4AE0     		b	.L43
 674              	.L42:
 510:../Generated_Code/AdcLdd1.c ****   }
 511:../Generated_Code/AdcLdd1.c ****   /* If calibration is successfully passed place calibrated value into gain registers */
 512:../Generated_Code/AdcLdd1.c ****   /* Cumulated gradually because of undefined behavior: the order of volatile accesses is undefined
 513:../Generated_Code/AdcLdd1.c ****   GainValue = ADC_PDD_GetPlus0CalibrationValue(ADC0_BASE_PTR); /* Find plus gain value */
 675              		.loc 1 513 0
 676 0016 274B     		ldr	r3, .L44
 677 0018 DB6C     		ldr	r3, [r3, #76]
 678 001a FB60     		str	r3, [r7, #12]
 514:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus1CalibrationValue(ADC0_BASE_PTR);
 679              		.loc 1 514 0
 680 001c 254B     		ldr	r3, .L44
 681 001e 9B6C     		ldr	r3, [r3, #72]
 682 0020 FA68     		ldr	r2, [r7, #12]
 683 0022 D318     		add	r3, r2, r3
 684 0024 FB60     		str	r3, [r7, #12]
 515:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus2CalibrationValue(ADC0_BASE_PTR);
 685              		.loc 1 515 0
 686 0026 234B     		ldr	r3, .L44
 687 0028 5B6C     		ldr	r3, [r3, #68]
 688 002a FA68     		ldr	r2, [r7, #12]
 689 002c D318     		add	r3, r2, r3
 690 002e FB60     		str	r3, [r7, #12]
 516:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus3CalibrationValue(ADC0_BASE_PTR);
 691              		.loc 1 516 0
 692 0030 204B     		ldr	r3, .L44
 693 0032 1B6C     		ldr	r3, [r3, #64]
 694 0034 FA68     		ldr	r2, [r7, #12]
 695 0036 D318     		add	r3, r2, r3
 696 0038 FB60     		str	r3, [r7, #12]
 517:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlus4CalibrationValue(ADC0_BASE_PTR);
 697              		.loc 1 517 0
 698 003a 1E4B     		ldr	r3, .L44
 699 003c DB6B     		ldr	r3, [r3, #60]
 700 003e FA68     		ldr	r2, [r7, #12]
 701 0040 D318     		add	r3, r2, r3
 702 0042 FB60     		str	r3, [r7, #12]
 518:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetPlusSCalibrationValue(ADC0_BASE_PTR);
 703              		.loc 1 518 0
 704 0044 1B4B     		ldr	r3, .L44
 705 0046 9B6B     		ldr	r3, [r3, #56]
 706 0048 FA68     		ldr	r2, [r7, #12]
 707 004a D318     		add	r3, r2, r3
 708 004c FB60     		str	r3, [r7, #12]
 519:../Generated_Code/AdcLdd1.c ****   GainValue = (GainValue >> 1U) | 0x8000U;
 709              		.loc 1 519 0
 710 004e FB68     		ldr	r3, [r7, #12]
 711 0050 5B08     		lsr	r3, r3, #1
 712 0052 8022     		mov	r2, #128
 713 0054 1202     		lsl	r2, r2, #8
 714 0056 1343     		orr	r3, r2
 715 0058 FB60     		str	r3, [r7, #12]
 520:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetPlusGainValue(ADC0_BASE_PTR,GainValue); /* Set plus gain value */
 716              		.loc 1 520 0
 717 005a 164B     		ldr	r3, .L44
 718 005c FA68     		ldr	r2, [r7, #12]
 719 005e DA62     		str	r2, [r3, #44]
 521:../Generated_Code/AdcLdd1.c ****   GainValue = ADC_PDD_GetMinus0CalibrationValue(ADC0_BASE_PTR); /* Find minus gain value */
 720              		.loc 1 521 0
 721 0060 144B     		ldr	r3, .L44
 722 0062 DB6E     		ldr	r3, [r3, #108]
 723 0064 FB60     		str	r3, [r7, #12]
 522:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus1CalibrationValue(ADC0_BASE_PTR);
 724              		.loc 1 522 0
 725 0066 134B     		ldr	r3, .L44
 726 0068 9B6E     		ldr	r3, [r3, #104]
 727 006a FA68     		ldr	r2, [r7, #12]
 728 006c D318     		add	r3, r2, r3
 729 006e FB60     		str	r3, [r7, #12]
 523:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus2CalibrationValue(ADC0_BASE_PTR);
 730              		.loc 1 523 0
 731 0070 104B     		ldr	r3, .L44
 732 0072 5B6E     		ldr	r3, [r3, #100]
 733 0074 FA68     		ldr	r2, [r7, #12]
 734 0076 D318     		add	r3, r2, r3
 735 0078 FB60     		str	r3, [r7, #12]
 524:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus3CalibrationValue(ADC0_BASE_PTR);
 736              		.loc 1 524 0
 737 007a 0E4B     		ldr	r3, .L44
 738 007c 1B6E     		ldr	r3, [r3, #96]
 739 007e FA68     		ldr	r2, [r7, #12]
 740 0080 D318     		add	r3, r2, r3
 741 0082 FB60     		str	r3, [r7, #12]
 525:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinus4CalibrationValue(ADC0_BASE_PTR);
 742              		.loc 1 525 0
 743 0084 0B4B     		ldr	r3, .L44
 744 0086 DB6D     		ldr	r3, [r3, #92]
 745 0088 FA68     		ldr	r2, [r7, #12]
 746 008a D318     		add	r3, r2, r3
 747 008c FB60     		str	r3, [r7, #12]
 526:../Generated_Code/AdcLdd1.c ****   GainValue += ADC_PDD_GetMinusSCalibrationValue(ADC0_BASE_PTR);
 748              		.loc 1 526 0
 749 008e 094B     		ldr	r3, .L44
 750 0090 9B6D     		ldr	r3, [r3, #88]
 751 0092 FA68     		ldr	r2, [r7, #12]
 752 0094 D318     		add	r3, r2, r3
 753 0096 FB60     		str	r3, [r7, #12]
 527:../Generated_Code/AdcLdd1.c ****   GainValue =  (GainValue >> 1U) | 0x8000U;
 754              		.loc 1 527 0
 755 0098 FB68     		ldr	r3, [r7, #12]
 756 009a 5B08     		lsr	r3, r3, #1
 757 009c 8022     		mov	r2, #128
 758 009e 1202     		lsl	r2, r2, #8
 759 00a0 1343     		orr	r3, r2
 760 00a2 FB60     		str	r3, [r7, #12]
 528:../Generated_Code/AdcLdd1.c ****   ADC_PDD_SetMinusGainValue(ADC0_BASE_PTR,GainValue); /* Set minus gain value */
 761              		.loc 1 528 0
 762 00a4 034B     		ldr	r3, .L44
 763 00a6 FA68     		ldr	r2, [r7, #12]
 764 00a8 1A63     		str	r2, [r3, #48]
 529:../Generated_Code/AdcLdd1.c ****   return ERR_OK;
 765              		.loc 1 529 0
 766 00aa 0023     		mov	r3, #0
 767              	.L43:
 530:../Generated_Code/AdcLdd1.c **** }
 768              		.loc 1 530 0
 769 00ac 181C     		mov	r0, r3
 770 00ae BD46     		mov	sp, r7
 771 00b0 04B0     		add	sp, sp, #16
 772              		@ sp needed for prologue
 773 00b2 80BD     		pop	{r7, pc}
 774              	.L45:
 775              		.align	2
 776              	.L44:
 777 00b4 00B00340 		.word	1073983488
 778              		.cfi_endproc
 779              	.LFE7:
 781              		.section	.text.AdcLdd1_MeasurementCompleteInterrupt,"ax",%progbits
 782              		.align	2
 783              		.global	AdcLdd1_MeasurementCompleteInterrupt
 784              		.code	16
 785              		.thumb_func
 787              	AdcLdd1_MeasurementCompleteInterrupt:
 788              	.LFB8:
 531:../Generated_Code/AdcLdd1.c **** 
 532:../Generated_Code/AdcLdd1.c **** /*
 533:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 534:../Generated_Code/AdcLdd1.c **** **     Method      :  AdcLdd1_MeasurementCompleteInterrupt (component ADC_LDD)
 535:../Generated_Code/AdcLdd1.c **** **
 536:../Generated_Code/AdcLdd1.c **** **     Description :
 537:../Generated_Code/AdcLdd1.c **** **         Measurement complete interrupt handler
 538:../Generated_Code/AdcLdd1.c **** **         This method is internal. It is used by Processor Expert only.
 539:../Generated_Code/AdcLdd1.c **** ** ===================================================================
 540:../Generated_Code/AdcLdd1.c **** */
 541:../Generated_Code/AdcLdd1.c **** PE_ISR(AdcLdd1_MeasurementCompleteInterrupt)
 542:../Generated_Code/AdcLdd1.c **** {
 789              		.loc 1 542 0
 790              		.cfi_startproc
 791 0000 80B5     		push	{r7, lr}
 792              	.LCFI24:
 793              		.cfi_def_cfa_offset 8
 794              		.cfi_offset 7, -8
 795              		.cfi_offset 14, -4
 796 0002 82B0     		sub	sp, sp, #8
 797              	.LCFI25:
 798              		.cfi_def_cfa_offset 16
 799 0004 00AF     		add	r7, sp, #0
 800              	.LCFI26:
 801              		.cfi_def_cfa_register 7
 543:../Generated_Code/AdcLdd1.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 544:../Generated_Code/AdcLdd1.c ****   AdcLdd1_TDeviceDataPtr DeviceDataPrv = INT_ADC0__DEFAULT_RTOS_ISRPARAM;
 802              		.loc 1 544 0
 803 0006 084B     		ldr	r3, .L47
 804 0008 1B68     		ldr	r3, [r3]
 805 000a 7B60     		str	r3, [r7, #4]
 545:../Generated_Code/AdcLdd1.c ****   DeviceDataPrv->CompleteStatus = TRUE; /* Set measurement complete status flag */
 806              		.loc 1 545 0
 807 000c 7B68     		ldr	r3, [r7, #4]
 808 000e 0122     		mov	r2, #1
 809 0010 9A70     		strb	r2, [r3, #2]
 546:../Generated_Code/AdcLdd1.c ****   AdcLdd1_OnMeasurementComplete(DeviceDataPrv->UserData);
 810              		.loc 1 546 0
 811 0012 7B68     		ldr	r3, [r7, #4]
 812 0014 5B68     		ldr	r3, [r3, #4]
 813 0016 181C     		mov	r0, r3
 814 0018 FFF7FEFF 		bl	AdcLdd1_OnMeasurementComplete
 547:../Generated_Code/AdcLdd1.c ****   (void)ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, 0U); /* Clear conversion complete flag */
 815              		.loc 1 547 0
 816 001c 034B     		ldr	r3, .L47+4
 817 001e 1B69     		ldr	r3, [r3, #16]
 548:../Generated_Code/AdcLdd1.c **** }
 818              		.loc 1 548 0
 819 0020 BD46     		mov	sp, r7
 820 0022 02B0     		add	sp, sp, #8
 821              		@ sp needed for prologue
 822 0024 80BD     		pop	{r7, pc}
 823              	.L48:
 824 0026 C046     		.align	2
 825              	.L47:
 826 0028 00000000 		.word	INT_ADC0__DEFAULT_RTOS_ISRPARAM
 827 002c 00B00340 		.word	1073983488
 828              		.cfi_endproc
 829              	.LFE8:
 831              		.text
 832              	.Letext0:
 833              		.file 2 "D:/CodeWarrior/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 834              		.file 3 "../Generated_Code/PE_Types.h"
 835              		.file 4 "D:/CodeWarrior/CW MCU v10.6/MCU/ProcessorExpert/lib/Kinetis/iofiles/MKL25Z4.h"
 836              		.file 5 "../Generated_Code/AdcLdd1.h"
 837              		.file 6 "../Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 AdcLdd1.c
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:18     .rodata.ChannelToPin:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:21     .rodata.ChannelToPin:00000000 ChannelToPin
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:25     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:28     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:31     .bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:34     .bss.INT_ADC0__DEFAULT_RTOS_ISRPARAM:00000000 INT_ADC0__DEFAULT_RTOS_ISRPARAM
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:37     .text.AdcLdd1_Init:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:42     .text.AdcLdd1_Init:00000000 AdcLdd1_Init
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:165    .text.AdcLdd1_Init:000000b0 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:178    .text.AdcLdd1_StartSingleMeasurement:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:183    .text.AdcLdd1_StartSingleMeasurement:00000000 AdcLdd1_StartSingleMeasurement
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:240    .text.AdcLdd1_StartSingleMeasurement:00000040 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:245    .text.AdcLdd1_CancelMeasurement:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:250    .text.AdcLdd1_CancelMeasurement:00000000 AdcLdd1_CancelMeasurement
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:288    .text.AdcLdd1_CancelMeasurement:00000024 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:293    .text.AdcLdd1_CreateSampleGroup:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:298    .text.AdcLdd1_CreateSampleGroup:00000000 AdcLdd1_CreateSampleGroup
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:381    .text.AdcLdd1_CreateSampleGroup:00000064 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:387    .text.AdcLdd1_GetMeasuredValues:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:392    .text.AdcLdd1_GetMeasuredValues:00000000 AdcLdd1_GetMeasuredValues
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:463    .text.AdcLdd1_GetMeasuredValues:0000005c $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:468    .text.AdcLdd1_GetMeasurementCompleteStatus:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:473    .text.AdcLdd1_GetMeasurementCompleteStatus:00000000 AdcLdd1_GetMeasurementCompleteStatus
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:572    .text.AdcLdd1_GetMeasurementCompleteStatus:0000007c $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:578    .text.AdcLdd1_StartCalibration:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:583    .text.AdcLdd1_StartCalibration:00000000 AdcLdd1_StartCalibration
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:639    .text.AdcLdd1_StartCalibration:00000040 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:644    .text.AdcLdd1_GetCalibrationResultStatus:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:649    .text.AdcLdd1_GetCalibrationResultStatus:00000000 AdcLdd1_GetCalibrationResultStatus
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:777    .text.AdcLdd1_GetCalibrationResultStatus:000000b4 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:782    .text.AdcLdd1_MeasurementCompleteInterrupt:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:787    .text.AdcLdd1_MeasurementCompleteInterrupt:00000000 AdcLdd1_MeasurementCompleteInterrupt
C:\Users\SKRA~1\AppData\Local\Temp\ccYGr6qc.s:826    .text.AdcLdd1_MeasurementCompleteInterrupt:00000028 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
SR_lock
SR_reg
AdcLdd1_OnMeasurementComplete
