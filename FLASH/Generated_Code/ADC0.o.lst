   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"ADC0.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	8
  22      00000000 
  23              		.section	.text.ADC0_Init,"ax",%progbits
  24              		.align	2
  25              		.global	ADC0_Init
  26              		.code	16
  27              		.thumb_func
  29              	ADC0_Init:
  30              	.LFB0:
  31              		.file 1 "../Generated_Code/ADC0.c"
   1:../Generated_Code/ADC0.c **** /* ###################################################################
   2:../Generated_Code/ADC0.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/ADC0.c **** **     Filename    : ADC0.c
   4:../Generated_Code/ADC0.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/ADC0.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/ADC0.c **** **     Component   : ADC_LDD
   7:../Generated_Code/ADC0.c **** **     Version     : Component 01.183, Driver 01.08, CPU db: 3.00.000
   8:../Generated_Code/ADC0.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/ADC0.c **** **     Date/Time   : 2016-01-22, 18:56, # CodeGen: 23
  10:../Generated_Code/ADC0.c **** **     Abstract    :
  11:../Generated_Code/ADC0.c **** **         This device "ADC_LDD" implements an A/D converter,
  12:../Generated_Code/ADC0.c **** **         its control methods and interrupt/event handling procedure.
  13:../Generated_Code/ADC0.c **** **     Settings    :
  14:../Generated_Code/ADC0.c **** **          Component name                                 : ADC0
  15:../Generated_Code/ADC0.c **** **          A/D converter                                  : ADC0
  16:../Generated_Code/ADC0.c **** **          Discontinuous mode                             : no
  17:../Generated_Code/ADC0.c **** **          Interrupt service/event                        : Disabled
  18:../Generated_Code/ADC0.c **** **          DMA                                            : Disabled
  19:../Generated_Code/ADC0.c **** **          A/D channel list                               : 2
  20:../Generated_Code/ADC0.c **** **            Channel 0                                    : 
  21:../Generated_Code/ADC0.c **** **              Channel mode                               : Single Ended
  22:../Generated_Code/ADC0.c **** **                Input                                    : 
  23:../Generated_Code/ADC0.c **** **                  A/D channel (pin)                      : ADC0_DP0/ADC0_SE0/PTE20/TPM1_CH0/UART0
  24:../Generated_Code/ADC0.c **** **                  A/D channel (pin) signal               : 
  25:../Generated_Code/ADC0.c **** **            Channel 1                                    : 
  26:../Generated_Code/ADC0.c **** **              Channel mode                               : Single Ended
  27:../Generated_Code/ADC0.c **** **                Input                                    : 
  28:../Generated_Code/ADC0.c **** **                  A/D channel (pin)                      : ADC0_DM0/ADC0_SE4a/PTE21/TPM1_CH1/UART
  29:../Generated_Code/ADC0.c **** **                  A/D channel (pin) signal               : 
  30:../Generated_Code/ADC0.c **** **          Static sample groups                           : Enabled
  31:../Generated_Code/ADC0.c **** **            Sample group list                            : 2
  32:../Generated_Code/ADC0.c **** **              Group 0                                    : 
  33:../Generated_Code/ADC0.c **** **                Sample list                              : 1
  34:../Generated_Code/ADC0.c **** **                  Sample 0                               : Enabled
  35:../Generated_Code/ADC0.c **** **                    Channel index                        : 0
  36:../Generated_Code/ADC0.c **** **              Group 1                                    : 
  37:../Generated_Code/ADC0.c **** **                Sample list                              : 1
  38:../Generated_Code/ADC0.c **** **                  Sample 0                               : Enabled
  39:../Generated_Code/ADC0.c **** **                    Channel index                        : 1
  40:../Generated_Code/ADC0.c **** **          A/D resolution                                 : 12 bits
  41:../Generated_Code/ADC0.c **** **          Low-power mode                                 : Disabled
  42:../Generated_Code/ADC0.c **** **          High-speed conversion mode                     : Disabled
  43:../Generated_Code/ADC0.c **** **          Asynchro clock output                          : Disabled
  44:../Generated_Code/ADC0.c **** **          Sample time                                    : 4 clock periods
  45:../Generated_Code/ADC0.c **** **          Number of conversions                          : 1
  46:../Generated_Code/ADC0.c **** **          Conversion time                                : 7.692308 µs
  47:../Generated_Code/ADC0.c **** **          ADC clock                                      : 2.6 MHz (384.615 ns)
  48:../Generated_Code/ADC0.c **** **          Single conversion time - Single-ended          : 14.823 us
  49:../Generated_Code/ADC0.c **** **          Single conversion time - Differential          : 18.669 us
  50:../Generated_Code/ADC0.c **** **          Additional conversion time - Single-ended      : 7.692 us
  51:../Generated_Code/ADC0.c **** **          Additional conversion time - Differential      : 11.538 us
  52:../Generated_Code/ADC0.c **** **          Result type                                    : unsigned 16 bits, right justified
  53:../Generated_Code/ADC0.c **** **          Trigger                                        : Disabled
  54:../Generated_Code/ADC0.c **** **          Voltage reference                              : 
  55:../Generated_Code/ADC0.c **** **            High voltage reference                       : 
  56:../Generated_Code/ADC0.c **** **              Volt. ref. pin                             : VDDA
  57:../Generated_Code/ADC0.c **** **              Volt. ref pin signal                       : 
  58:../Generated_Code/ADC0.c **** **            Low voltage reference                        : 
  59:../Generated_Code/ADC0.c **** **              Volt. ref. pin                             : VSSA
  60:../Generated_Code/ADC0.c **** **              Volt. ref pin signal                       : 
  61:../Generated_Code/ADC0.c **** **          Initialization                                 : 
  62:../Generated_Code/ADC0.c **** **            Enabled in init. code                        : yes
  63:../Generated_Code/ADC0.c **** **            Auto initialization                          : yes
  64:../Generated_Code/ADC0.c **** **            Event mask                                   : 
  65:../Generated_Code/ADC0.c **** **              OnMeasurementComplete                      : Disabled
  66:../Generated_Code/ADC0.c **** **              OnError                                    : Disabled
  67:../Generated_Code/ADC0.c **** **          CPU clock/configuration selection              : 
  68:../Generated_Code/ADC0.c **** **            Clock configuration 0                        : This component enabled
  69:../Generated_Code/ADC0.c **** **            Clock configuration 1                        : This component disabled
  70:../Generated_Code/ADC0.c **** **            Clock configuration 2                        : This component disabled
  71:../Generated_Code/ADC0.c **** **            Clock configuration 3                        : This component disabled
  72:../Generated_Code/ADC0.c **** **            Clock configuration 4                        : This component disabled
  73:../Generated_Code/ADC0.c **** **            Clock configuration 5                        : This component disabled
  74:../Generated_Code/ADC0.c **** **            Clock configuration 6                        : This component disabled
  75:../Generated_Code/ADC0.c **** **            Clock configuration 7                        : This component disabled
  76:../Generated_Code/ADC0.c **** **     Contents    :
  77:../Generated_Code/ADC0.c **** **         Init                   - LDD_TDeviceData* ADC0_Init(LDD_TUserData *UserDataPtr);
  78:../Generated_Code/ADC0.c **** **         Enable                 - LDD_TError ADC0_Enable(LDD_TDeviceData *DeviceDataPtr);
  79:../Generated_Code/ADC0.c **** **         Disable                - LDD_TError ADC0_Disable(LDD_TDeviceData *DeviceDataPtr);
  80:../Generated_Code/ADC0.c **** **         StartSingleMeasurement - LDD_TError ADC0_StartSingleMeasurement(LDD_TDeviceData *DeviceD
  81:../Generated_Code/ADC0.c **** **         GetMeasuredValues      - LDD_TError ADC0_GetMeasuredValues(LDD_TDeviceData *DeviceDataPt
  82:../Generated_Code/ADC0.c **** **
  83:../Generated_Code/ADC0.c **** **     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
  84:../Generated_Code/ADC0.c **** **     All Rights Reserved.
  85:../Generated_Code/ADC0.c **** **     
  86:../Generated_Code/ADC0.c **** **     Redistribution and use in source and binary forms, with or without modification,
  87:../Generated_Code/ADC0.c **** **     are permitted provided that the following conditions are met:
  88:../Generated_Code/ADC0.c **** **     
  89:../Generated_Code/ADC0.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  90:../Generated_Code/ADC0.c **** **       of conditions and the following disclaimer.
  91:../Generated_Code/ADC0.c **** **     
  92:../Generated_Code/ADC0.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
  93:../Generated_Code/ADC0.c **** **       list of conditions and the following disclaimer in the documentation and/or
  94:../Generated_Code/ADC0.c **** **       other materials provided with the distribution.
  95:../Generated_Code/ADC0.c **** **     
  96:../Generated_Code/ADC0.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
  97:../Generated_Code/ADC0.c **** **       contributors may be used to endorse or promote products derived from this
  98:../Generated_Code/ADC0.c **** **       software without specific prior written permission.
  99:../Generated_Code/ADC0.c **** **     
 100:../Generated_Code/ADC0.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 101:../Generated_Code/ADC0.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 102:../Generated_Code/ADC0.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 103:../Generated_Code/ADC0.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 104:../Generated_Code/ADC0.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 105:../Generated_Code/ADC0.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 106:../Generated_Code/ADC0.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 107:../Generated_Code/ADC0.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 108:../Generated_Code/ADC0.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 109:../Generated_Code/ADC0.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 110:../Generated_Code/ADC0.c **** **     
 111:../Generated_Code/ADC0.c **** **     http: www.freescale.com
 112:../Generated_Code/ADC0.c **** **     mail: support@freescale.com
 113:../Generated_Code/ADC0.c **** ** ###################################################################*/
 114:../Generated_Code/ADC0.c **** /*!
 115:../Generated_Code/ADC0.c **** ** @file ADC0.c
 116:../Generated_Code/ADC0.c **** ** @version 01.08
 117:../Generated_Code/ADC0.c **** ** @brief
 118:../Generated_Code/ADC0.c **** **         This device "ADC_LDD" implements an A/D converter,
 119:../Generated_Code/ADC0.c **** **         its control methods and interrupt/event handling procedure.
 120:../Generated_Code/ADC0.c **** */         
 121:../Generated_Code/ADC0.c **** /*!
 122:../Generated_Code/ADC0.c **** **  @addtogroup ADC0_module ADC0 module documentation
 123:../Generated_Code/ADC0.c **** **  @{
 124:../Generated_Code/ADC0.c **** */         
 125:../Generated_Code/ADC0.c **** 
 126:../Generated_Code/ADC0.c **** /* MODULE ADC0. */
 127:../Generated_Code/ADC0.c **** 
 128:../Generated_Code/ADC0.c **** #include "ADC0.h"
 129:../Generated_Code/ADC0.c **** /* {Default RTOS Adapter} No RTOS includes */
 130:../Generated_Code/ADC0.c **** 
 131:../Generated_Code/ADC0.c **** #ifdef __cplusplus
 132:../Generated_Code/ADC0.c **** extern "C" { 
 133:../Generated_Code/ADC0.c **** #endif
 134:../Generated_Code/ADC0.c **** 
 135:../Generated_Code/ADC0.c **** #define ADC0_AVAILABLE_CHANNEL0_31_PIN_MASK (LDD_ADC_CHANNEL_0_PIN | LDD_ADC_CHANNEL_1_PIN) /*!< Ma
 136:../Generated_Code/ADC0.c **** #define ADC0_AVAILABLE_CHANNEL32_63_PIN_MASK 0x00U /*!< Mask of all allocated channel pins from 32 
 137:../Generated_Code/ADC0.c **** #define ADC0_AVAILABLE_TRIGGER_PIN_MASK 0x00U /*!< Mask of all allocated trigger pins */
 138:../Generated_Code/ADC0.c **** #define ADC0_AVAILABLE_VOLT_REF_PIN_MASK (LDD_ADC_LOW_VOLT_REF_PIN | LDD_ADC_HIGH_VOLT_REF_PIN) /*!
 139:../Generated_Code/ADC0.c **** 
 140:../Generated_Code/ADC0.c **** typedef struct {
 141:../Generated_Code/ADC0.c ****   uint8_t  SampleCount;                /* Sample count */
 142:../Generated_Code/ADC0.c ****   uint8_t  StatusControlRegVal[ADC0_MAX_HW_SAMPLE_COUNT]; /* Status and control register values */
 143:../Generated_Code/ADC0.c **** } TStaticSampleGroup;
 144:../Generated_Code/ADC0.c **** 
 145:../Generated_Code/ADC0.c **** typedef struct {
 146:../Generated_Code/ADC0.c ****   uint8_t SampleCount;                 /* Number of samples in the last selected/created sample gro
 147:../Generated_Code/ADC0.c ****   bool EnUser;                         /* Enable/Disable device */
 148:../Generated_Code/ADC0.c ****   uint8_t FirstSample;                 /* First sample of group store */
 149:../Generated_Code/ADC0.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 150:../Generated_Code/ADC0.c **** } ADC0_TDeviceData;                    /* Device data structure type */
 151:../Generated_Code/ADC0.c **** 
 152:../Generated_Code/ADC0.c **** typedef ADC0_TDeviceData* ADC0_TDeviceDataPtr ; /* Pointer to the device data structure. */
 153:../Generated_Code/ADC0.c **** 
 154:../Generated_Code/ADC0.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 155:../Generated_Code/ADC0.c **** static ADC0_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 156:../Generated_Code/ADC0.c **** /*
 157:../Generated_Code/ADC0.c **** ** ===================================================================
 158:../Generated_Code/ADC0.c **** **     Method      :  ADC0_Init (component ADC_LDD)
 159:../Generated_Code/ADC0.c **** */
 160:../Generated_Code/ADC0.c **** /*!
 161:../Generated_Code/ADC0.c **** **     @brief
 162:../Generated_Code/ADC0.c **** **         Initializes the device. Allocates memory for the device data
 163:../Generated_Code/ADC0.c **** **         structure, allocates interrupt vectors and sets interrupt
 164:../Generated_Code/ADC0.c **** **         priority, sets pin routing, sets timing, etc.
 165:../Generated_Code/ADC0.c **** **         If the "Enable in init. code" is set to "yes" value then the
 166:../Generated_Code/ADC0.c **** **         device is also enabled(see the description of the Enable()
 167:../Generated_Code/ADC0.c **** **         method). In this case the Enable() method is not necessary
 168:../Generated_Code/ADC0.c **** **         and needn't to be generated. 
 169:../Generated_Code/ADC0.c **** **         This method can be called only once. Before the second call
 170:../Generated_Code/ADC0.c **** **         of Init() the Deinit() must be called first.
 171:../Generated_Code/ADC0.c **** **     @param
 172:../Generated_Code/ADC0.c **** **         UserDataPtr     - Pointer to the user or
 173:../Generated_Code/ADC0.c **** **                           RTOS specific data. This pointer will be
 174:../Generated_Code/ADC0.c **** **                           passed as an event or callback parameter.
 175:../Generated_Code/ADC0.c **** **     @return
 176:../Generated_Code/ADC0.c **** **                         - Device data structure pointer.
 177:../Generated_Code/ADC0.c **** */
 178:../Generated_Code/ADC0.c **** /* ===================================================================*/
 179:../Generated_Code/ADC0.c **** LDD_TDeviceData* ADC0_Init(LDD_TUserData *UserDataPtr)
 180:../Generated_Code/ADC0.c **** {
  32              		.loc 1 180 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              	.LCFI0:
  36              		.cfi_def_cfa_offset 8
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
  39 0002 84B0     		sub	sp, sp, #16
  40              	.LCFI1:
  41              		.cfi_def_cfa_offset 24
  42 0004 00AF     		add	r7, sp, #0
  43              	.LCFI2:
  44              		.cfi_def_cfa_register 7
  45 0006 7860     		str	r0, [r7, #4]
 181:../Generated_Code/ADC0.c ****   /* Allocate LDD device structure */
 182:../Generated_Code/ADC0.c ****   ADC0_TDeviceDataPtr DeviceDataPrv;
 183:../Generated_Code/ADC0.c **** 
 184:../Generated_Code/ADC0.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 185:../Generated_Code/ADC0.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
  46              		.loc 1 185 0
  47 0008 1E4B     		ldr	r3, .L3
  48 000a FB60     		str	r3, [r7, #12]
 186:../Generated_Code/ADC0.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
  49              		.loc 1 186 0
  50 000c FB68     		ldr	r3, [r7, #12]
  51 000e 7A68     		ldr	r2, [r7, #4]
  52 0010 5A60     		str	r2, [r3, #4]
 187:../Generated_Code/ADC0.c ****   DeviceDataPrv->SampleCount = 0U;     /* Initializing SampleCount for right access of some methods
  53              		.loc 1 187 0
  54 0012 FB68     		ldr	r3, [r7, #12]
  55 0014 0022     		mov	r2, #0
  56 0016 1A70     		strb	r2, [r3]
 188:../Generated_Code/ADC0.c ****   DeviceDataPrv->EnUser = TRUE;        /* Enable device */
  57              		.loc 1 188 0
  58 0018 FB68     		ldr	r3, [r7, #12]
  59 001a 0122     		mov	r2, #1
  60 001c 5A70     		strb	r2, [r3, #1]
 189:../Generated_Code/ADC0.c ****   /* SIM_SCGC6: ADC0=1 */
 190:../Generated_Code/ADC0.c ****   SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;
  61              		.loc 1 190 0
  62 001e 1A4A     		ldr	r2, .L3+4
  63 0020 1949     		ldr	r1, .L3+4
  64 0022 1A4B     		ldr	r3, .L3+8
  65 0024 CB58     		ldr	r3, [r1, r3]
  66 0026 8021     		mov	r1, #128
  67 0028 0905     		lsl	r1, r1, #20
  68 002a 1943     		orr	r1, r3
  69 002c 174B     		ldr	r3, .L3+8
  70 002e D150     		str	r1, [r2, r3]
 191:../Generated_Code/ADC0.c ****   /* PORTE_PCR20: ISF=0,MUX=0 */
 192:../Generated_Code/ADC0.c ****   PORTE_PCR20 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
  71              		.loc 1 192 0
  72 0030 174B     		ldr	r3, .L3+12
  73 0032 174A     		ldr	r2, .L3+12
  74 0034 116D     		ldr	r1, [r2, #80]
  75 0036 174A     		ldr	r2, .L3+16
  76 0038 0A40     		and	r2, r1
  77 003a 1A65     		str	r2, [r3, #80]
 193:../Generated_Code/ADC0.c ****   /* PORTE_PCR21: ISF=0,MUX=0 */
 194:../Generated_Code/ADC0.c ****   PORTE_PCR21 &= (uint32_t)~(uint32_t)((PORT_PCR_ISF_MASK | PORT_PCR_MUX(0x07)));
  78              		.loc 1 194 0
  79 003c 144B     		ldr	r3, .L3+12
  80 003e 144A     		ldr	r2, .L3+12
  81 0040 516D     		ldr	r1, [r2, #84]
  82 0042 144A     		ldr	r2, .L3+16
  83 0044 0A40     		and	r2, r1
  84 0046 5A65     		str	r2, [r3, #84]
 195:../Generated_Code/ADC0.c ****   /* ADC0_CFG2: MUXSEL=0 */
 196:../Generated_Code/ADC0.c ****   ADC0_CFG2 &= (uint32_t)~(uint32_t)(ADC_CFG2_MUXSEL_MASK);
  85              		.loc 1 196 0
  86 0048 134B     		ldr	r3, .L3+20
  87 004a 134A     		ldr	r2, .L3+20
  88 004c D268     		ldr	r2, [r2, #12]
  89 004e 1021     		mov	r1, #16
  90 0050 8A43     		bic	r2, r1
  91 0052 DA60     		str	r2, [r3, #12]
 197:../Generated_Code/ADC0.c ****   /* ADC0_CFG1: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=
 198:../Generated_Code/ADC0.c ****   ADC0_CFG1 = ADC_CFG1_ADIV(0x01) |
  92              		.loc 1 198 0
  93 0054 104B     		ldr	r3, .L3+20
  94 0056 2722     		mov	r2, #39
  95 0058 9A60     		str	r2, [r3, #8]
 199:../Generated_Code/ADC0.c ****               ADC_CFG1_MODE(0x01) |
 200:../Generated_Code/ADC0.c ****               ADC_CFG1_ADICLK(0x03);
 201:../Generated_Code/ADC0.c ****   /* ADC0_CFG2: MUXSEL=0,ADACKEN=0,ADHSC=0,ADLSTS=0 */
 202:../Generated_Code/ADC0.c ****   ADC0_CFG2 &= (uint32_t)~(uint32_t)(
  96              		.loc 1 202 0
  97 005a 0F4B     		ldr	r3, .L3+20
  98 005c 0E4A     		ldr	r2, .L3+20
  99 005e D268     		ldr	r2, [r2, #12]
 100 0060 1F21     		mov	r1, #31
 101 0062 8A43     		bic	r2, r1
 102 0064 DA60     		str	r2, [r3, #12]
 203:../Generated_Code/ADC0.c ****                 ADC_CFG2_MUXSEL_MASK |
 204:../Generated_Code/ADC0.c ****                 ADC_CFG2_ADACKEN_MASK |
 205:../Generated_Code/ADC0.c ****                 ADC_CFG2_ADHSC_MASK |
 206:../Generated_Code/ADC0.c ****                 ADC_CFG2_ADLSTS(0x03)
 207:../Generated_Code/ADC0.c ****                );
 208:../Generated_Code/ADC0.c ****   /* ADC0_SC2: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 209:../Generated_Code/ADC0.c ****   ADC0_SC2 = ADC_SC2_REFSEL(0x01);
 103              		.loc 1 209 0
 104 0066 0C4B     		ldr	r3, .L3+20
 105 0068 0122     		mov	r2, #1
 106 006a 1A62     		str	r2, [r3, #32]
 210:../Generated_Code/ADC0.c ****   /* ADC0_SC3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0
 211:../Generated_Code/ADC0.c ****   ADC0_SC3 = (ADC_SC3_CALF_MASK | ADC_SC3_AVGS(0x00));
 107              		.loc 1 211 0
 108 006c 0A4B     		ldr	r3, .L3+20
 109 006e 4022     		mov	r2, #64
 110 0070 5A62     		str	r2, [r3, #36]
 212:../Generated_Code/ADC0.c ****   /* Registration of the device structure */
 213:../Generated_Code/ADC0.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_ADC0_ID,DeviceDataPrv);
 111              		.loc 1 213 0
 112 0072 0A4B     		ldr	r3, .L3+24
 113 0074 FA68     		ldr	r2, [r7, #12]
 114 0076 9A61     		str	r2, [r3, #24]
 214:../Generated_Code/ADC0.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 115              		.loc 1 214 0
 116 0078 FB68     		ldr	r3, [r7, #12]
 215:../Generated_Code/ADC0.c **** }
 117              		.loc 1 215 0
 118 007a 181C     		mov	r0, r3
 119 007c BD46     		mov	sp, r7
 120 007e 04B0     		add	sp, sp, #16
 121              		@ sp needed for prologue
 122 0080 80BD     		pop	{r7, pc}
 123              	.L4:
 124 0082 C046     		.align	2
 125              	.L3:
 126 0084 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 127 0088 00700440 		.word	1074032640
 128 008c 3C100000 		.word	4156
 129 0090 00D00440 		.word	1074057216
 130 0094 FFF8FFFE 		.word	-16779009
 131 0098 00B00340 		.word	1073983488
 132 009c 00000000 		.word	PE_LDD_DeviceDataList
 133              		.cfi_endproc
 134              	.LFE0:
 136              		.section	.text.ADC0_Enable,"ax",%progbits
 137              		.align	2
 138              		.global	ADC0_Enable
 139              		.code	16
 140              		.thumb_func
 142              	ADC0_Enable:
 143              	.LFB1:
 216:../Generated_Code/ADC0.c **** 
 217:../Generated_Code/ADC0.c **** /*
 218:../Generated_Code/ADC0.c **** ** ===================================================================
 219:../Generated_Code/ADC0.c **** **     Method      :  ADC0_Enable (component ADC_LDD)
 220:../Generated_Code/ADC0.c **** */
 221:../Generated_Code/ADC0.c **** /*!
 222:../Generated_Code/ADC0.c **** **     @brief
 223:../Generated_Code/ADC0.c **** **         Enables ADC device. If possible, this method switches on A/D
 224:../Generated_Code/ADC0.c **** **         converter device, voltage reference, etc. This method is
 225:../Generated_Code/ADC0.c **** **         intended to be used together with [Disable()] method to
 226:../Generated_Code/ADC0.c **** **         temporary switch On/Off the device after the device is
 227:../Generated_Code/ADC0.c **** **         initialized. This method is required if the [Enabled in init.
 228:../Generated_Code/ADC0.c **** **         code] property is set to "no" value.
 229:../Generated_Code/ADC0.c **** **     @param
 230:../Generated_Code/ADC0.c **** **         DeviceDataPtr   - Device data structure
 231:../Generated_Code/ADC0.c **** **                           pointer returned by [Init] method.
 232:../Generated_Code/ADC0.c **** **     @return
 233:../Generated_Code/ADC0.c **** **                         - Error code, possible codes:
 234:../Generated_Code/ADC0.c **** **                           ERR_OK - OK
 235:../Generated_Code/ADC0.c **** **                           ERR_SPEED - The device doesn't work in the
 236:../Generated_Code/ADC0.c **** **                           active clock configuration
 237:../Generated_Code/ADC0.c **** */
 238:../Generated_Code/ADC0.c **** /* ===================================================================*/
 239:../Generated_Code/ADC0.c **** LDD_TError ADC0_Enable(LDD_TDeviceData *DeviceDataPtr)
 240:../Generated_Code/ADC0.c **** {
 144              		.loc 1 240 0
 145              		.cfi_startproc
 146 0000 80B5     		push	{r7, lr}
 147              	.LCFI3:
 148              		.cfi_def_cfa_offset 8
 149              		.cfi_offset 7, -8
 150              		.cfi_offset 14, -4
 151 0002 82B0     		sub	sp, sp, #8
 152              	.LCFI4:
 153              		.cfi_def_cfa_offset 16
 154 0004 00AF     		add	r7, sp, #0
 155              	.LCFI5:
 156              		.cfi_def_cfa_register 7
 157 0006 7860     		str	r0, [r7, #4]
 241:../Generated_Code/ADC0.c ****   ((ADC0_TDeviceDataPtr)DeviceDataPtr)->EnUser = TRUE; /* Set the flag "device enabled" */
 158              		.loc 1 241 0
 159 0008 7B68     		ldr	r3, [r7, #4]
 160 000a 0122     		mov	r2, #1
 161 000c 5A70     		strb	r2, [r3, #1]
 242:../Generated_Code/ADC0.c ****   return ERR_OK;                       /* If yes then set the flag "device enabled" */
 162              		.loc 1 242 0
 163 000e 0023     		mov	r3, #0
 243:../Generated_Code/ADC0.c **** }
 164              		.loc 1 243 0
 165 0010 181C     		mov	r0, r3
 166 0012 BD46     		mov	sp, r7
 167 0014 02B0     		add	sp, sp, #8
 168              		@ sp needed for prologue
 169 0016 80BD     		pop	{r7, pc}
 170              		.cfi_endproc
 171              	.LFE1:
 173              		.section	.text.ADC0_Disable,"ax",%progbits
 174              		.align	2
 175              		.global	ADC0_Disable
 176              		.code	16
 177              		.thumb_func
 179              	ADC0_Disable:
 180              	.LFB2:
 244:../Generated_Code/ADC0.c **** 
 245:../Generated_Code/ADC0.c **** /*
 246:../Generated_Code/ADC0.c **** ** ===================================================================
 247:../Generated_Code/ADC0.c **** **     Method      :  ADC0_Disable (component ADC_LDD)
 248:../Generated_Code/ADC0.c **** */
 249:../Generated_Code/ADC0.c **** /*!
 250:../Generated_Code/ADC0.c **** **     @brief
 251:../Generated_Code/ADC0.c **** **         Disables the ADC device. If possible, this method switches
 252:../Generated_Code/ADC0.c **** **         off A/D converter device, voltage reference, etc. (for
 253:../Generated_Code/ADC0.c **** **         example to avoid power consumption and possible interference).
 254:../Generated_Code/ADC0.c **** **         When the device is disabled, some component methods should
 255:../Generated_Code/ADC0.c **** **         not be called. If so, error ERR_DISABLED is reported. This
 256:../Generated_Code/ADC0.c **** **         method is intended to be used together with [Enable()]
 257:../Generated_Code/ADC0.c **** **         method to temporary switch On/Off the device after the
 258:../Generated_Code/ADC0.c **** **         device is initialized. This method is not required. The
 259:../Generated_Code/ADC0.c **** **         [Deinit()] method can be used to switch off and uninstall
 260:../Generated_Code/ADC0.c **** **         the device.
 261:../Generated_Code/ADC0.c **** **     @param
 262:../Generated_Code/ADC0.c **** **         DeviceDataPtr   - Device data structure
 263:../Generated_Code/ADC0.c **** **                           pointer returned by [Init] method.
 264:../Generated_Code/ADC0.c **** **     @return
 265:../Generated_Code/ADC0.c **** **                         - Error code, possible codes:
 266:../Generated_Code/ADC0.c **** **                           ERR_OK - OK
 267:../Generated_Code/ADC0.c **** **                           ERR_SPEED - The device doesn't work in the
 268:../Generated_Code/ADC0.c **** **                           active clock configuration
 269:../Generated_Code/ADC0.c **** */
 270:../Generated_Code/ADC0.c **** /* ===================================================================*/
 271:../Generated_Code/ADC0.c **** LDD_TError ADC0_Disable(LDD_TDeviceData *DeviceDataPtr)
 272:../Generated_Code/ADC0.c **** {
 181              		.loc 1 272 0
 182              		.cfi_startproc
 183 0000 80B5     		push	{r7, lr}
 184              	.LCFI6:
 185              		.cfi_def_cfa_offset 8
 186              		.cfi_offset 7, -8
 187              		.cfi_offset 14, -4
 188 0002 82B0     		sub	sp, sp, #8
 189              	.LCFI7:
 190              		.cfi_def_cfa_offset 16
 191 0004 00AF     		add	r7, sp, #0
 192              	.LCFI8:
 193              		.cfi_def_cfa_register 7
 194 0006 7860     		str	r0, [r7, #4]
 273:../Generated_Code/ADC0.c ****   ((ADC0_TDeviceDataPtr)DeviceDataPtr)->EnUser = FALSE; /* Set the flag "device disabled" */
 195              		.loc 1 273 0
 196 0008 7B68     		ldr	r3, [r7, #4]
 197 000a 0022     		mov	r2, #0
 198 000c 5A70     		strb	r2, [r3, #1]
 274:../Generated_Code/ADC0.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 199              		.loc 1 274 0
 200 000e 074B     		ldr	r3, .L9
 201 0010 064A     		ldr	r2, .L9
 202 0012 126A     		ldr	r2, [r2, #32]
 203 0014 4021     		mov	r1, #64
 204 0016 8A43     		bic	r2, r1
 205 0018 1A62     		str	r2, [r3, #32]
 275:../Generated_Code/ADC0.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, 0x1FU); /* Disable device */
 206              		.loc 1 275 0
 207 001a 044B     		ldr	r3, .L9
 208 001c 1F22     		mov	r2, #31
 209 001e 1A60     		str	r2, [r3]
 276:../Generated_Code/ADC0.c ****   return ERR_OK;                       /* If yes then set the flag "device enabled" */
 210              		.loc 1 276 0
 211 0020 0023     		mov	r3, #0
 277:../Generated_Code/ADC0.c **** }
 212              		.loc 1 277 0
 213 0022 181C     		mov	r0, r3
 214 0024 BD46     		mov	sp, r7
 215 0026 02B0     		add	sp, sp, #8
 216              		@ sp needed for prologue
 217 0028 80BD     		pop	{r7, pc}
 218              	.L10:
 219 002a C046     		.align	2
 220              	.L9:
 221 002c 00B00340 		.word	1073983488
 222              		.cfi_endproc
 223              	.LFE2:
 225              		.section	.text.ADC0_StartSingleMeasurement,"ax",%progbits
 226              		.align	2
 227              		.global	ADC0_StartSingleMeasurement
 228              		.code	16
 229              		.thumb_func
 231              	ADC0_StartSingleMeasurement:
 232              	.LFB3:
 278:../Generated_Code/ADC0.c **** 
 279:../Generated_Code/ADC0.c **** /*
 280:../Generated_Code/ADC0.c **** ** ===================================================================
 281:../Generated_Code/ADC0.c **** **     Method      :  ADC0_StartSingleMeasurement (component ADC_LDD)
 282:../Generated_Code/ADC0.c **** */
 283:../Generated_Code/ADC0.c **** /*!
 284:../Generated_Code/ADC0.c **** **     @brief
 285:../Generated_Code/ADC0.c **** **         This method starts one measurement of the selected group of
 286:../Generated_Code/ADC0.c **** **         samples and exits immediately. This is ADC SW trigger method.
 287:../Generated_Code/ADC0.c **** **         The group of samples for measurement is specified by
 288:../Generated_Code/ADC0.c **** **         preceding call to [SelectSampleGroup()] or
 289:../Generated_Code/ADC0.c **** **         [CreateSampleGroup] method. 
 290:../Generated_Code/ADC0.c **** **         DMA disabled: The [OnMeasurementComplete() ] event is
 291:../Generated_Code/ADC0.c **** **         invoked after the measurement is done and if the event is
 292:../Generated_Code/ADC0.c **** **         enabled. Results of the measurement can be read by the
 293:../Generated_Code/ADC0.c **** **         [GetMeasuredValues()] method. 
 294:../Generated_Code/ADC0.c **** **         DMA enabled: DMA request from configured ADC is enabled
 295:../Generated_Code/ADC0.c **** **         automatically. The [OnMeasurementComplete() ] event is
 296:../Generated_Code/ADC0.c **** **         invoked after the requested number of results are
 297:../Generated_Code/ADC0.c **** **         transferred to destination buffer by DMA and if the event is
 298:../Generated_Code/ADC0.c **** **         enabled. [GetMeasuredValues()] method is not available if
 299:../Generated_Code/ADC0.c **** **         DMA mode is enabled. If the DMA transfer was completed
 300:../Generated_Code/ADC0.c **** **         before and DMA is not recofingured, DMA error can occur. See
 301:../Generated_Code/ADC0.c **** **         also [SetBuffer()] method. 
 302:../Generated_Code/ADC0.c **** **         The state of the measurement can be also polled by the
 303:../Generated_Code/ADC0.c **** **         [GetMeasurementCompleteStatus()] method. The [Discontinuous
 304:../Generated_Code/ADC0.c **** **         mode] doesn't support this method.
 305:../Generated_Code/ADC0.c **** **     @param
 306:../Generated_Code/ADC0.c **** **         DeviceDataPtr   - Device data structure
 307:../Generated_Code/ADC0.c **** **                           pointer returned by [Init] method.
 308:../Generated_Code/ADC0.c **** **     @return
 309:../Generated_Code/ADC0.c **** **                         - Error code, possible codes:
 310:../Generated_Code/ADC0.c **** **                           ERR_OK - OK
 311:../Generated_Code/ADC0.c **** **                           ERR_SPEED - The device doesn't work in the
 312:../Generated_Code/ADC0.c **** **                           active clock configuration
 313:../Generated_Code/ADC0.c **** **                           ERR_DISABLED - Component is disabled
 314:../Generated_Code/ADC0.c **** **                           ERR_BUSY - A measurement is in progress 
 315:../Generated_Code/ADC0.c **** */
 316:../Generated_Code/ADC0.c **** /* ===================================================================*/
 317:../Generated_Code/ADC0.c **** LDD_TError ADC0_StartSingleMeasurement(LDD_TDeviceData *DeviceDataPtr)
 318:../Generated_Code/ADC0.c **** {
 233              		.loc 1 318 0
 234              		.cfi_startproc
 235 0000 80B5     		push	{r7, lr}
 236              	.LCFI9:
 237              		.cfi_def_cfa_offset 8
 238              		.cfi_offset 7, -8
 239              		.cfi_offset 14, -4
 240 0002 82B0     		sub	sp, sp, #8
 241              	.LCFI10:
 242              		.cfi_def_cfa_offset 16
 243 0004 00AF     		add	r7, sp, #0
 244              	.LCFI11:
 245              		.cfi_def_cfa_register 7
 246 0006 7860     		str	r0, [r7, #4]
 319:../Generated_Code/ADC0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
 320:../Generated_Code/ADC0.c ****      property to the "yes" value in the "Configuration inspector" */
 321:../Generated_Code/ADC0.c ****   if (!((ADC0_TDeviceDataPtr)DeviceDataPtr)->EnUser) { /* Is the device disabled by user? */
 247              		.loc 1 321 0
 248 0008 7B68     		ldr	r3, [r7, #4]
 249 000a 5B78     		ldrb	r3, [r3, #1]
 250 000c 002B     		cmp	r3, #0
 251 000e 01D1     		bne	.L12
 322:../Generated_Code/ADC0.c ****     return ERR_DISABLED;               /* If yes then error */
 252              		.loc 1 322 0
 253 0010 0723     		mov	r3, #7
 254 0012 17E0     		b	.L13
 255              	.L12:
 323:../Generated_Code/ADC0.c ****   }
 324:../Generated_Code/ADC0.c ****   if (ADC_PDD_GetConversionActiveFlag(ADC0_BASE_PTR) != 0U) { /* Last measurement still pending? */
 256              		.loc 1 324 0
 257 0014 0D4B     		ldr	r3, .L15
 258 0016 1A6A     		ldr	r2, [r3, #32]
 259 0018 8023     		mov	r3, #128
 260 001a 1340     		and	r3, r2
 261 001c 01D0     		beq	.L14
 325:../Generated_Code/ADC0.c ****     return ERR_BUSY;                   /* Yes, return ERR_BUSY */
 262              		.loc 1 325 0
 263 001e 0823     		mov	r3, #8
 264 0020 10E0     		b	.L13
 265              	.L14:
 326:../Generated_Code/ADC0.c ****   }
 327:../Generated_Code/ADC0.c ****   ADC_PDD_SetContinuousMode(ADC0_BASE_PTR, ADC_PDD_ONE_CONVERSION); /* Set one conversion mode */
 266              		.loc 1 327 0
 267 0022 0A4B     		ldr	r3, .L15
 268 0024 094A     		ldr	r2, .L15
 269 0026 526A     		ldr	r2, [r2, #36]
 270 0028 0821     		mov	r1, #8
 271 002a 8A43     		bic	r2, r1
 272 002c 5A62     		str	r2, [r3, #36]
 328:../Generated_Code/ADC0.c ****   ADC_PDD_SetConversionTriggerType(ADC0_BASE_PTR, ADC_PDD_SW_TRIGGER); /* Select SW triggering */
 273              		.loc 1 328 0
 274 002e 074B     		ldr	r3, .L15
 275 0030 064A     		ldr	r2, .L15
 276 0032 126A     		ldr	r2, [r2, #32]
 277 0034 4021     		mov	r1, #64
 278 0036 8A43     		bic	r2, r1
 279 0038 1A62     		str	r2, [r3, #32]
 329:../Generated_Code/ADC0.c ****   ADC_PDD_WriteStatusControl1Reg(ADC0_BASE_PTR, 0U, ((ADC0_TDeviceDataPtr)DeviceDataPtr)->FirstSamp
 280              		.loc 1 329 0
 281 003a 044B     		ldr	r3, .L15
 282 003c 7A68     		ldr	r2, [r7, #4]
 283 003e 9278     		ldrb	r2, [r2, #2]
 284 0040 1A60     		str	r2, [r3]
 330:../Generated_Code/ADC0.c ****   return ERR_OK;                       /* OK */
 285              		.loc 1 330 0
 286 0042 0023     		mov	r3, #0
 287              	.L13:
 331:../Generated_Code/ADC0.c **** }
 288              		.loc 1 331 0
 289 0044 181C     		mov	r0, r3
 290 0046 BD46     		mov	sp, r7
 291 0048 02B0     		add	sp, sp, #8
 292              		@ sp needed for prologue
 293 004a 80BD     		pop	{r7, pc}
 294              	.L16:
 295              		.align	2
 296              	.L15:
 297 004c 00B00340 		.word	1073983488
 298              		.cfi_endproc
 299              	.LFE3:
 301              		.section	.text.ADC0_GetMeasuredValues,"ax",%progbits
 302              		.align	2
 303              		.global	ADC0_GetMeasuredValues
 304              		.code	16
 305              		.thumb_func
 307              	ADC0_GetMeasuredValues:
 308              	.LFB4:
 332:../Generated_Code/ADC0.c **** 
 333:../Generated_Code/ADC0.c **** /*
 334:../Generated_Code/ADC0.c **** ** ===================================================================
 335:../Generated_Code/ADC0.c **** **     Method      :  ADC0_GetMeasuredValues (component ADC_LDD)
 336:../Generated_Code/ADC0.c **** */
 337:../Generated_Code/ADC0.c **** /*!
 338:../Generated_Code/ADC0.c **** **     @brief
 339:../Generated_Code/ADC0.c **** **         This method copies results of the last measurement to the
 340:../Generated_Code/ADC0.c **** **         user supplied buffer. Data size depends on the size of
 341:../Generated_Code/ADC0.c **** **         measured sample group (see [SelectSampleGroup()] or
 342:../Generated_Code/ADC0.c **** **         [CreateSampleGroup()] method). Data representation is
 343:../Generated_Code/ADC0.c **** **         defined by the [Result type] property. Typically this method
 344:../Generated_Code/ADC0.c **** **         is called from [OnMeasurementComplete] event to get results
 345:../Generated_Code/ADC0.c **** **         of the last measurement. This method is not available if DMA
 346:../Generated_Code/ADC0.c **** **         is enabled.
 347:../Generated_Code/ADC0.c **** **     @param
 348:../Generated_Code/ADC0.c **** **         DeviceDataPtr   - Device data structure
 349:../Generated_Code/ADC0.c **** **                           pointer returned by [Init] method.
 350:../Generated_Code/ADC0.c **** **     @param
 351:../Generated_Code/ADC0.c **** **         BufferPtr       - Pointer to the start of the
 352:../Generated_Code/ADC0.c **** **                           buffer for new results. Count of stored
 353:../Generated_Code/ADC0.c **** **                           measured values equals to the count of the
 354:../Generated_Code/ADC0.c **** **                           samples in the active sample group. It is
 355:../Generated_Code/ADC0.c **** **                           in the user responsibility to provide
 356:../Generated_Code/ADC0.c **** **                           buffer with appropriate size.
 357:../Generated_Code/ADC0.c **** **     @return
 358:../Generated_Code/ADC0.c **** **                         - Error code, possible codes:
 359:../Generated_Code/ADC0.c **** **                           ERR_OK - OK
 360:../Generated_Code/ADC0.c **** **                           ERR_SPEED - The device doesn't work in the
 361:../Generated_Code/ADC0.c **** **                           active clock configuration
 362:../Generated_Code/ADC0.c **** **                           ERR_DISABLED - Component is disabled
 363:../Generated_Code/ADC0.c **** */
 364:../Generated_Code/ADC0.c **** /* ===================================================================*/
 365:../Generated_Code/ADC0.c **** LDD_TError ADC0_GetMeasuredValues(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr)
 366:../Generated_Code/ADC0.c **** {
 309              		.loc 1 366 0
 310              		.cfi_startproc
 311 0000 80B5     		push	{r7, lr}
 312              	.LCFI12:
 313              		.cfi_def_cfa_offset 8
 314              		.cfi_offset 7, -8
 315              		.cfi_offset 14, -4
 316 0002 84B0     		sub	sp, sp, #16
 317              	.LCFI13:
 318              		.cfi_def_cfa_offset 24
 319 0004 00AF     		add	r7, sp, #0
 320              	.LCFI14:
 321              		.cfi_def_cfa_register 7
 322 0006 7860     		str	r0, [r7, #4]
 323 0008 3960     		str	r1, [r7]
 367:../Generated_Code/ADC0.c ****   uint8_t Sample;
 368:../Generated_Code/ADC0.c ****   ADC0_TResultData *pBuffer = (ADC0_TResultData *)BufferPtr;
 324              		.loc 1 368 0
 325 000a 3B68     		ldr	r3, [r7]
 326 000c BB60     		str	r3, [r7, #8]
 369:../Generated_Code/ADC0.c **** 
 370:../Generated_Code/ADC0.c ****   /* Device state test - this test can be disabled by setting the "Ignore enable test"
 371:../Generated_Code/ADC0.c ****      property to the "yes" value in the "Configuration inspector" */
 372:../Generated_Code/ADC0.c ****   if (!((ADC0_TDeviceDataPtr)DeviceDataPtr)->EnUser) { /* Is the device disabled by user? */
 327              		.loc 1 372 0
 328 000e 7B68     		ldr	r3, [r7, #4]
 329 0010 5B78     		ldrb	r3, [r3, #1]
 330 0012 002B     		cmp	r3, #0
 331 0014 01D1     		bne	.L18
 373:../Generated_Code/ADC0.c ****     return ERR_DISABLED;               /* If yes then error */
 332              		.loc 1 373 0
 333 0016 0723     		mov	r3, #7
 334 0018 22E0     		b	.L19
 335              	.L18:
 374:../Generated_Code/ADC0.c ****   }
 375:../Generated_Code/ADC0.c ****   /* Copy values from result registers defined in the active sample
 376:../Generated_Code/ADC0.c ****      group to the user supplied buffer */
 377:../Generated_Code/ADC0.c ****   for (Sample = 0U; Sample < ((ADC0_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 336              		.loc 1 377 0
 337 001a 3B1C     		mov	r3, r7
 338 001c 0F33     		add	r3, r3, #15
 339 001e 0022     		mov	r2, #0
 340 0020 1A70     		strb	r2, [r3]
 341 0022 15E0     		b	.L20
 342              	.L21:
 378:../Generated_Code/ADC0.c ****     pBuffer[Sample] =(uint16_t)(ADC_PDD_GetResultValueRaw(ADC0_BASE_PTR, Sample));
 343              		.loc 1 378 0
 344 0024 3B1C     		mov	r3, r7
 345 0026 0F33     		add	r3, r3, #15
 346 0028 1B78     		ldrb	r3, [r3]
 347 002a 5B00     		lsl	r3, r3, #1
 348 002c BA68     		ldr	r2, [r7, #8]
 349 002e D318     		add	r3, r2, r3
 350 0030 0D4A     		ldr	r2, .L22
 351 0032 391C     		mov	r1, r7
 352 0034 0F31     		add	r1, r1, #15
 353 0036 0978     		ldrb	r1, [r1]
 354 0038 0431     		add	r1, r1, #4
 355 003a 8900     		lsl	r1, r1, #2
 356 003c 8A58     		ldr	r2, [r1, r2]
 357 003e 92B2     		uxth	r2, r2
 358 0040 1A80     		strh	r2, [r3]
 377:../Generated_Code/ADC0.c ****   for (Sample = 0U; Sample < ((ADC0_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 359              		.loc 1 377 0
 360 0042 3B1C     		mov	r3, r7
 361 0044 0F33     		add	r3, r3, #15
 362 0046 3A1C     		mov	r2, r7
 363 0048 0F32     		add	r2, r2, #15
 364 004a 1278     		ldrb	r2, [r2]
 365 004c 0132     		add	r2, r2, #1
 366 004e 1A70     		strb	r2, [r3]
 367              	.L20:
 377:../Generated_Code/ADC0.c ****   for (Sample = 0U; Sample < ((ADC0_TDeviceDataPtr)DeviceDataPtr)->SampleCount; Sample++) {
 368              		.loc 1 377 0 is_stmt 0
 369 0050 7B68     		ldr	r3, [r7, #4]
 370 0052 1B78     		ldrb	r3, [r3]
 371 0054 3A1C     		mov	r2, r7
 372 0056 0F32     		add	r2, r2, #15
 373 0058 1278     		ldrb	r2, [r2]
 374 005a 9A42     		cmp	r2, r3
 375 005c E2D3     		bcc	.L21
 379:../Generated_Code/ADC0.c ****   }
 380:../Generated_Code/ADC0.c ****   return ERR_OK;                       /* OK */
 376              		.loc 1 380 0 is_stmt 1
 377 005e 0023     		mov	r3, #0
 378              	.L19:
 381:../Generated_Code/ADC0.c **** }
 379              		.loc 1 381 0
 380 0060 181C     		mov	r0, r3
 381 0062 BD46     		mov	sp, r7
 382 0064 04B0     		add	sp, sp, #16
 383              		@ sp needed for prologue
 384 0066 80BD     		pop	{r7, pc}
 385              	.L23:
 386              		.align	2
 387              	.L22:
 388 0068 00B00340 		.word	1073983488
 389              		.cfi_endproc
 390              	.LFE4:
 392              		.text
 393              	.Letext0:
 394              		.file 2 "D:/CodeWarrior/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 395              		.file 3 "../Generated_Code/PE_Types.h"
 396              		.file 4 "D:/CodeWarrior/CW MCU v10.6/MCU/ProcessorExpert/lib/Kinetis/iofiles/MKL25Z4.h"
 397              		.file 5 "../Generated_Code/ADC0.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ADC0.c
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:24     .text.ADC0_Init:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:29     .text.ADC0_Init:00000000 ADC0_Init
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:126    .text.ADC0_Init:00000084 $d
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:137    .text.ADC0_Enable:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:142    .text.ADC0_Enable:00000000 ADC0_Enable
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:174    .text.ADC0_Disable:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:179    .text.ADC0_Disable:00000000 ADC0_Disable
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:221    .text.ADC0_Disable:0000002c $d
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:226    .text.ADC0_StartSingleMeasurement:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:231    .text.ADC0_StartSingleMeasurement:00000000 ADC0_StartSingleMeasurement
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:297    .text.ADC0_StartSingleMeasurement:0000004c $d
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:302    .text.ADC0_GetMeasuredValues:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:307    .text.ADC0_GetMeasuredValues:00000000 ADC0_GetMeasuredValues
C:\Users\SKRA~1\AppData\Local\Temp\cccqmJBW.s:388    .text.ADC0_GetMeasuredValues:00000068 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
PE_LDD_DeviceDataList
