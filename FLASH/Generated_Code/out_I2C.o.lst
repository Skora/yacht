   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"out_I2C.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC,"aw",%nobits
  18              		.align	2
  21              	DeviceDataPrv__DEFAULT_RTOS_ALLOC:
  22 0000 00000000 		.space	20
  22      00000000 
  22      00000000 
  22      00000000 
  22      00000000 
  23              		.section	.bss.INT_I2C1__DEFAULT_RTOS_ISRPARAM,"aw",%nobits
  24              		.align	2
  27              	INT_I2C1__DEFAULT_RTOS_ISRPARAM:
  28 0000 00000000 		.space	4
  29              		.section	.text.out_I2C_Interrupt,"ax",%progbits
  30              		.align	2
  31              		.global	out_I2C_Interrupt
  32              		.code	16
  33              		.thumb_func
  35              	out_I2C_Interrupt:
  36              	.LFB0:
  37              		.file 1 "../Generated_Code/out_I2C.c"
   1:../Generated_Code/out_I2C.c **** /* ###################################################################
   2:../Generated_Code/out_I2C.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/out_I2C.c **** **     Filename    : out_I2C.c
   4:../Generated_Code/out_I2C.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/out_I2C.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/out_I2C.c **** **     Component   : I2C_LDD
   7:../Generated_Code/out_I2C.c **** **     Version     : Component 01.016, Driver 01.07, CPU db: 3.00.000
   8:../Generated_Code/out_I2C.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/out_I2C.c **** **     Date/Time   : 2015-12-12, 12:27, # CodeGen: 18
  10:../Generated_Code/out_I2C.c **** **     Abstract    :
  11:../Generated_Code/out_I2C.c **** **          This component encapsulates the internal I2C communication
  12:../Generated_Code/out_I2C.c **** **          interface. The implementation of the interface is based
  13:../Generated_Code/out_I2C.c **** **          on the Philips I2C-bus specification version 2.0.
  14:../Generated_Code/out_I2C.c **** **          Interface features:
  15:../Generated_Code/out_I2C.c **** **          MASTER mode
  16:../Generated_Code/out_I2C.c **** **            - Multi master communication
  17:../Generated_Code/out_I2C.c **** **            - The combined format of communication possible
  18:../Generated_Code/out_I2C.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
  19:../Generated_Code/out_I2C.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
  20:../Generated_Code/out_I2C.c **** **            - Acknowledge polling provided
  21:../Generated_Code/out_I2C.c **** **            - No wait state initiated when a slave device holds the SCL line low
  22:../Generated_Code/out_I2C.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
  23:../Generated_Code/out_I2C.c **** **            - Invalid start/stop condition detection provided
  24:../Generated_Code/out_I2C.c **** **          SLAVE mode
  25:../Generated_Code/out_I2C.c **** **            - 7-bit slave addressing
  26:../Generated_Code/out_I2C.c **** **            - General call address detection provided
  27:../Generated_Code/out_I2C.c **** **     Settings    :
  28:../Generated_Code/out_I2C.c **** **          Component name                                 : out_I2C
  29:../Generated_Code/out_I2C.c **** **          I2C channel                                    : I2C1
  30:../Generated_Code/out_I2C.c **** **          Interrupt service                              : Enabled
  31:../Generated_Code/out_I2C.c **** **            Interrupt                                    : INT_I2C1
  32:../Generated_Code/out_I2C.c **** **            Interrupt priority                           : medium priority
  33:../Generated_Code/out_I2C.c **** **          Settings                                       : 
  34:../Generated_Code/out_I2C.c **** **            Mode selection                               : MASTER
  35:../Generated_Code/out_I2C.c **** **            MASTER mode                                  : Enabled
  36:../Generated_Code/out_I2C.c **** **              Initialization                             : 
  37:../Generated_Code/out_I2C.c **** **                Address mode                             : 7-bit addressing
  38:../Generated_Code/out_I2C.c **** **                Target slave address init                : 0
  39:../Generated_Code/out_I2C.c **** **            SLAVE mode                                   : Disabled
  40:../Generated_Code/out_I2C.c **** **            Pins                                         : 
  41:../Generated_Code/out_I2C.c **** **              SDA pin                                    : 
  42:../Generated_Code/out_I2C.c **** **                SDA pin                                  : PTE0/UART1_TX/RTC_CLKOUT/CMP0_OUT/I2C1
  43:../Generated_Code/out_I2C.c **** **                SDA pin signal                           : 
  44:../Generated_Code/out_I2C.c **** **              SCL pin                                    : 
  45:../Generated_Code/out_I2C.c **** **                SCL pin                                  : PTE1/SPI1_MOSI/UART1_RX/SPI1_MISO/I2C1
  46:../Generated_Code/out_I2C.c **** **                SCL pin signal                           : 
  47:../Generated_Code/out_I2C.c **** **              High drive select                          : Disabled
  48:../Generated_Code/out_I2C.c **** **              Input Glitch filter                        : 0
  49:../Generated_Code/out_I2C.c **** **            Internal frequency (multiplier factor)       : 24 MHz
  50:../Generated_Code/out_I2C.c **** **            Bits 0-2 of Frequency divider register       : 101
  51:../Generated_Code/out_I2C.c **** **            Bits 3-5 of Frequency divider register       : 100
  52:../Generated_Code/out_I2C.c **** **            SCL frequency                                : 75 kHz
  53:../Generated_Code/out_I2C.c **** **            SDA Hold                                     : 2.042 us
  54:../Generated_Code/out_I2C.c **** **            SCL start Hold                               : 6.583 us
  55:../Generated_Code/out_I2C.c **** **            SCL stop Hold                                : 6.708 us
  56:../Generated_Code/out_I2C.c **** **            Control acknowledge bit                      : Disabled
  57:../Generated_Code/out_I2C.c **** **            Low timeout                                  : Disabled
  58:../Generated_Code/out_I2C.c **** **          Initialization                                 : 
  59:../Generated_Code/out_I2C.c **** **            Enabled in init code                         : yes
  60:../Generated_Code/out_I2C.c **** **            Auto initialization                          : no
  61:../Generated_Code/out_I2C.c **** **            Event mask                                   : 
  62:../Generated_Code/out_I2C.c **** **              OnMasterBlockSent                          : Enabled
  63:../Generated_Code/out_I2C.c **** **              OnMasterBlockReceived                      : Enabled
  64:../Generated_Code/out_I2C.c **** **              OnMasterByteReceived                       : Disabled
  65:../Generated_Code/out_I2C.c **** **              OnSlaveBlockSent                           : Disabled
  66:../Generated_Code/out_I2C.c **** **              OnSlaveBlockReceived                       : Disabled
  67:../Generated_Code/out_I2C.c **** **              OnSlaveByteReceived                        : Disabled
  68:../Generated_Code/out_I2C.c **** **              OnSlaveRxRequest                           : Disabled
  69:../Generated_Code/out_I2C.c **** **              OnSlaveTxRequest                           : Disabled
  70:../Generated_Code/out_I2C.c **** **              OnSlaveGeneralCallAddr                     : Disabled
  71:../Generated_Code/out_I2C.c **** **              OnSlaveSmBusCallAddr                       : Disabled
  72:../Generated_Code/out_I2C.c **** **              OnSlaveSmBusAlertResponse                  : Disabled
  73:../Generated_Code/out_I2C.c **** **              OnError                                    : Disabled
  74:../Generated_Code/out_I2C.c **** **              OnBusStopDetected                          : Disabled
  75:../Generated_Code/out_I2C.c **** **          CPU clock/configuration selection              : 
  76:../Generated_Code/out_I2C.c **** **            Clock configuration 0                        : This component enabled
  77:../Generated_Code/out_I2C.c **** **            Clock configuration 1                        : This component disabled
  78:../Generated_Code/out_I2C.c **** **            Clock configuration 2                        : This component disabled
  79:../Generated_Code/out_I2C.c **** **            Clock configuration 3                        : This component disabled
  80:../Generated_Code/out_I2C.c **** **            Clock configuration 4                        : This component disabled
  81:../Generated_Code/out_I2C.c **** **            Clock configuration 5                        : This component disabled
  82:../Generated_Code/out_I2C.c **** **            Clock configuration 6                        : This component disabled
  83:../Generated_Code/out_I2C.c **** **            Clock configuration 7                        : This component disabled
  84:../Generated_Code/out_I2C.c **** **     Contents    :
  85:../Generated_Code/out_I2C.c **** **         Init               - LDD_TDeviceData* out_I2C_Init(LDD_TUserData *UserDataPtr);
  86:../Generated_Code/out_I2C.c **** **         MasterSendBlock    - LDD_TError out_I2C_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, 
  87:../Generated_Code/out_I2C.c **** **         MasterReceiveBlock - LDD_TError out_I2C_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPt
  88:../Generated_Code/out_I2C.c **** **
  89:../Generated_Code/out_I2C.c **** **     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
  90:../Generated_Code/out_I2C.c **** **     All Rights Reserved.
  91:../Generated_Code/out_I2C.c **** **     
  92:../Generated_Code/out_I2C.c **** **     Redistribution and use in source and binary forms, with or without modification,
  93:../Generated_Code/out_I2C.c **** **     are permitted provided that the following conditions are met:
  94:../Generated_Code/out_I2C.c **** **     
  95:../Generated_Code/out_I2C.c **** **     o Redistributions of source code must retain the above copyright notice, this list
  96:../Generated_Code/out_I2C.c **** **       of conditions and the following disclaimer.
  97:../Generated_Code/out_I2C.c **** **     
  98:../Generated_Code/out_I2C.c **** **     o Redistributions in binary form must reproduce the above copyright notice, this
  99:../Generated_Code/out_I2C.c **** **       list of conditions and the following disclaimer in the documentation and/or
 100:../Generated_Code/out_I2C.c **** **       other materials provided with the distribution.
 101:../Generated_Code/out_I2C.c **** **     
 102:../Generated_Code/out_I2C.c **** **     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
 103:../Generated_Code/out_I2C.c **** **       contributors may be used to endorse or promote products derived from this
 104:../Generated_Code/out_I2C.c **** **       software without specific prior written permission.
 105:../Generated_Code/out_I2C.c **** **     
 106:../Generated_Code/out_I2C.c **** **     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 107:../Generated_Code/out_I2C.c **** **     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 108:../Generated_Code/out_I2C.c **** **     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 109:../Generated_Code/out_I2C.c **** **     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 110:../Generated_Code/out_I2C.c **** **     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 111:../Generated_Code/out_I2C.c **** **     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 112:../Generated_Code/out_I2C.c **** **     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 113:../Generated_Code/out_I2C.c **** **     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 114:../Generated_Code/out_I2C.c **** **     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 115:../Generated_Code/out_I2C.c **** **     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 116:../Generated_Code/out_I2C.c **** **     
 117:../Generated_Code/out_I2C.c **** **     http: www.freescale.com
 118:../Generated_Code/out_I2C.c **** **     mail: support@freescale.com
 119:../Generated_Code/out_I2C.c **** ** ###################################################################*/
 120:../Generated_Code/out_I2C.c **** /*!
 121:../Generated_Code/out_I2C.c **** ** @file out_I2C.c
 122:../Generated_Code/out_I2C.c **** ** @version 01.07
 123:../Generated_Code/out_I2C.c **** ** @brief
 124:../Generated_Code/out_I2C.c **** **          This component encapsulates the internal I2C communication
 125:../Generated_Code/out_I2C.c **** **          interface. The implementation of the interface is based
 126:../Generated_Code/out_I2C.c **** **          on the Philips I2C-bus specification version 2.0.
 127:../Generated_Code/out_I2C.c **** **          Interface features:
 128:../Generated_Code/out_I2C.c **** **          MASTER mode
 129:../Generated_Code/out_I2C.c **** **            - Multi master communication
 130:../Generated_Code/out_I2C.c **** **            - The combined format of communication possible
 131:../Generated_Code/out_I2C.c **** **              (see SendStop parameter in MasterSend/ReceiveBlock method)
 132:../Generated_Code/out_I2C.c **** **            - 7-bit slave addressing (10-bit addressing can be made as well)
 133:../Generated_Code/out_I2C.c **** **            - Acknowledge polling provided
 134:../Generated_Code/out_I2C.c **** **            - No wait state initiated when a slave device holds the SCL line low
 135:../Generated_Code/out_I2C.c **** **            - Holding of the SCL line low by slave device recognized as 'not available bus'
 136:../Generated_Code/out_I2C.c **** **            - Invalid start/stop condition detection provided
 137:../Generated_Code/out_I2C.c **** **          SLAVE mode
 138:../Generated_Code/out_I2C.c **** **            - 7-bit slave addressing
 139:../Generated_Code/out_I2C.c **** **            - General call address detection provided
 140:../Generated_Code/out_I2C.c **** */         
 141:../Generated_Code/out_I2C.c **** /*!
 142:../Generated_Code/out_I2C.c **** **  @addtogroup out_I2C_module out_I2C module documentation
 143:../Generated_Code/out_I2C.c **** **  @{
 144:../Generated_Code/out_I2C.c **** */         
 145:../Generated_Code/out_I2C.c **** 
 146:../Generated_Code/out_I2C.c **** /* MODULE out_I2C. */
 147:../Generated_Code/out_I2C.c **** 
 148:../Generated_Code/out_I2C.c **** #include "Events.h"
 149:../Generated_Code/out_I2C.c **** #include "out_I2C.h"
 150:../Generated_Code/out_I2C.c **** #include "PORT_PDD.h"
 151:../Generated_Code/out_I2C.c **** #include "I2C_PDD.h"
 152:../Generated_Code/out_I2C.c **** /* {Default RTOS Adapter} No RTOS includes */
 153:../Generated_Code/out_I2C.c **** #include "IO_Map.h"
 154:../Generated_Code/out_I2C.c **** 
 155:../Generated_Code/out_I2C.c **** #ifdef __cplusplus
 156:../Generated_Code/out_I2C.c **** extern "C" {
 157:../Generated_Code/out_I2C.c **** #endif 
 158:../Generated_Code/out_I2C.c **** 
 159:../Generated_Code/out_I2C.c **** 
 160:../Generated_Code/out_I2C.c **** /* SerFlag bits */
 161:../Generated_Code/out_I2C.c **** #define MASTER_IN_PROGRES       0x01U  /* Communication is in progress (Master) */
 162:../Generated_Code/out_I2C.c **** 
 163:../Generated_Code/out_I2C.c **** typedef struct {
 164:../Generated_Code/out_I2C.c ****   uint8_t SerFlag;                     /* Flags for serial communication */
 165:../Generated_Code/out_I2C.c ****                                        /* Bits: 0 - Running int from TX */
 166:../Generated_Code/out_I2C.c ****   LDD_I2C_TSendStop SendStop;          /* Enable/Disable generate send stop condition after transmi
 167:../Generated_Code/out_I2C.c ****   LDD_I2C_TSize InpLenM;               /* The counter of input bufer's content */
 168:../Generated_Code/out_I2C.c ****   uint8_t *InpPtrM;                    /* Pointer to input buffer for Master mode */
 169:../Generated_Code/out_I2C.c ****   LDD_I2C_TSize OutLenM;               /* The counter of output bufer's content */
 170:../Generated_Code/out_I2C.c ****   uint8_t *OutPtrM;                    /* Pointer to output buffer for Master mode */
 171:../Generated_Code/out_I2C.c ****   LDD_TUserData *UserData;             /* RTOS device data structure */
 172:../Generated_Code/out_I2C.c **** } out_I2C_TDeviceData;
 173:../Generated_Code/out_I2C.c **** 
 174:../Generated_Code/out_I2C.c **** typedef out_I2C_TDeviceData *out_I2C_TDeviceDataPtr; /* Pointer to the device data structure. */
 175:../Generated_Code/out_I2C.c **** 
 176:../Generated_Code/out_I2C.c **** /* {Default RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
 177:../Generated_Code/out_I2C.c **** static out_I2C_TDeviceData DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 178:../Generated_Code/out_I2C.c **** /* {Default RTOS Adapter} Global variable used for passing a parameter into ISR */
 179:../Generated_Code/out_I2C.c **** static out_I2C_TDeviceDataPtr INT_I2C1__DEFAULT_RTOS_ISRPARAM;
 180:../Generated_Code/out_I2C.c **** 
 181:../Generated_Code/out_I2C.c **** #define AVAILABLE_EVENTS_MASK (LDD_I2C_ON_MASTER_BLOCK_SENT | LDD_I2C_ON_MASTER_BLOCK_RECEIVED)
 182:../Generated_Code/out_I2C.c **** 
 183:../Generated_Code/out_I2C.c **** /*
 184:../Generated_Code/out_I2C.c **** ** ===================================================================
 185:../Generated_Code/out_I2C.c **** **     Method      :  out_I2C_Interrupt (component I2C_LDD)
 186:../Generated_Code/out_I2C.c **** **
 187:../Generated_Code/out_I2C.c **** **     Description :
 188:../Generated_Code/out_I2C.c **** **         The method services the interrupt of the selected peripheral(s)
 189:../Generated_Code/out_I2C.c **** **         and eventually invokes event(s) of the component.
 190:../Generated_Code/out_I2C.c **** **         This method is internal. It is used by Processor Expert only.
 191:../Generated_Code/out_I2C.c **** ** ===================================================================
 192:../Generated_Code/out_I2C.c **** */
 193:../Generated_Code/out_I2C.c **** 
 194:../Generated_Code/out_I2C.c **** PE_ISR(out_I2C_Interrupt)
 195:../Generated_Code/out_I2C.c **** {
  38              		.loc 1 195 0
  39              		.cfi_startproc
  40 0000 90B5     		push	{r4, r7, lr}
  41              	.LCFI0:
  42              		.cfi_def_cfa_offset 12
  43              		.cfi_offset 4, -12
  44              		.cfi_offset 7, -8
  45              		.cfi_offset 14, -4
  46 0002 83B0     		sub	sp, sp, #12
  47              	.LCFI1:
  48              		.cfi_def_cfa_offset 24
  49 0004 00AF     		add	r7, sp, #0
  50              	.LCFI2:
  51              		.cfi_def_cfa_register 7
 196:../Generated_Code/out_I2C.c ****   /* {Default RTOS Adapter} ISR parameter is passed through the global variable */
 197:../Generated_Code/out_I2C.c ****   out_I2C_TDeviceDataPtr DeviceDataPrv = INT_I2C1__DEFAULT_RTOS_ISRPARAM;
  52              		.loc 1 197 0
  53 0006 7E4B     		ldr	r3, .L13
  54 0008 1B68     		ldr	r3, [r3]
  55 000a 7B60     		str	r3, [r7, #4]
 198:../Generated_Code/out_I2C.c ****   register uint8_t Status;             /* Temporary variable for status register */
 199:../Generated_Code/out_I2C.c **** 
 200:../Generated_Code/out_I2C.c ****   Status = I2C_PDD_ReadStatusReg(I2C1_BASE_PTR); /* Safe status register */
  56              		.loc 1 200 0
  57 000c 7D4B     		ldr	r3, .L13+4
  58 000e DB78     		ldrb	r3, [r3, #3]
  59 0010 DCB2     		uxtb	r4, r3
 201:../Generated_Code/out_I2C.c ****   I2C_PDD_ClearInterruptFlags(I2C1_BASE_PTR, (Status)); /* Clear interrupt flag */
  60              		.loc 1 201 0
  61 0012 7C4B     		ldr	r3, .L13+4
  62 0014 7B4A     		ldr	r2, .L13+4
  63 0016 D278     		ldrb	r2, [r2, #3]
  64 0018 D2B2     		uxtb	r2, r2
  65 001a D2B2     		uxtb	r2, r2
  66 001c 1221     		mov	r1, #18
  67 001e 8A43     		bic	r2, r1
  68 0020 D1B2     		uxtb	r1, r2
  69 0022 E2B2     		uxtb	r2, r4
  70 0024 0A43     		orr	r2, r1
  71 0026 D2B2     		uxtb	r2, r2
  72 0028 D2B2     		uxtb	r2, r2
  73 002a DA70     		strb	r2, [r3, #3]
 202:../Generated_Code/out_I2C.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
  74              		.loc 1 202 0
  75 002c 754B     		ldr	r3, .L13+4
  76 002e 9B78     		ldrb	r3, [r3, #2]
  77 0030 DBB2     		uxtb	r3, r3
  78 0032 1A1C     		mov	r2, r3
  79 0034 2023     		mov	r3, #32
  80 0036 1340     		and	r3, r2
  81 0038 00D1     		bne	.LCB42
  82 003a C2E0     		b	.L2	@long jump
  83              	.LCB42:
 203:../Generated_Code/out_I2C.c ****     if (I2C_PDD_GetTransmitMode(I2C1_BASE_PTR) == I2C_PDD_TX_DIRECTION) { /* Is device in Tx mode? 
  84              		.loc 1 203 0
  85 003c 714B     		ldr	r3, .L13+4
  86 003e 9B78     		ldrb	r3, [r3, #2]
  87 0040 DBB2     		uxtb	r3, r3
  88 0042 1A1C     		mov	r2, r3
  89 0044 1023     		mov	r3, #16
  90 0046 1340     		and	r3, r2
  91 0048 00D1     		bne	.LCB50
  92 004a 79E0     		b	.L3	@long jump
  93              	.LCB50:
 204:../Generated_Code/out_I2C.c ****       if ((Status & I2C_PDD_RX_ACKNOWLEDGE) != 0x00U){ /* NACK received? */
  94              		.loc 1 204 0
  95 004c 221C     		mov	r2, r4
  96 004e 0123     		mov	r3, #1
  97 0050 1340     		and	r3, r2
  98 0052 1DD0     		beq	.L4
 205:../Generated_Code/out_I2C.c ****         I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave mode (s
  99              		.loc 1 205 0
 100 0054 6B4B     		ldr	r3, .L13+4
 101 0056 6B4A     		ldr	r2, .L13+4
 102 0058 9278     		ldrb	r2, [r2, #2]
 103 005a D2B2     		uxtb	r2, r2
 104 005c 2021     		mov	r1, #32
 105 005e 8A43     		bic	r2, r1
 106 0060 D2B2     		uxtb	r2, r2
 107 0062 9A70     		strb	r2, [r3, #2]
 206:../Generated_Code/out_I2C.c ****         I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 108              		.loc 1 206 0
 109 0064 674B     		ldr	r3, .L13+4
 110 0066 674A     		ldr	r2, .L13+4
 111 0068 9278     		ldrb	r2, [r2, #2]
 112 006a D2B2     		uxtb	r2, r2
 113 006c 1021     		mov	r1, #16
 114 006e 8A43     		bic	r2, r1
 115 0070 D2B2     		uxtb	r2, r2
 116 0072 9A70     		strb	r2, [r3, #2]
 207:../Generated_Code/out_I2C.c ****         DeviceDataPrv->OutLenM = 0x00U; /* No character for sending */
 117              		.loc 1 207 0
 118 0074 7B68     		ldr	r3, [r7, #4]
 119 0076 0022     		mov	r2, #0
 120 0078 1A81     		strh	r2, [r3, #8]
 208:../Generated_Code/out_I2C.c ****         DeviceDataPrv->InpLenM = 0x00U; /* No character for reception */
 121              		.loc 1 208 0
 122 007a 7B68     		ldr	r3, [r7, #4]
 123 007c 0022     		mov	r2, #0
 124 007e 5A80     		strh	r2, [r3, #2]
 209:../Generated_Code/out_I2C.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* No character for sending or rec
 125              		.loc 1 209 0
 126 0080 7B68     		ldr	r3, [r7, #4]
 127 0082 1B78     		ldrb	r3, [r3]
 128 0084 0122     		mov	r2, #1
 129 0086 9343     		bic	r3, r2
 130 0088 DAB2     		uxtb	r2, r3
 131 008a 7B68     		ldr	r3, [r7, #4]
 132 008c 1A70     		strb	r2, [r3]
 133 008e B4E0     		b	.L1
 134              	.L4:
 210:../Generated_Code/out_I2C.c ****       } else {
 211:../Generated_Code/out_I2C.c ****         if (DeviceDataPrv->OutLenM != 0x00U) { /* Is any char. for transmitting? */
 135              		.loc 1 211 0
 136 0090 7B68     		ldr	r3, [r7, #4]
 137 0092 1B89     		ldrh	r3, [r3, #8]
 138 0094 002B     		cmp	r3, #0
 139 0096 0ED0     		beq	.L6
 212:../Generated_Code/out_I2C.c ****           DeviceDataPrv->OutLenM--;    /* Decrease number of chars for the transmit */
 140              		.loc 1 212 0
 141 0098 7B68     		ldr	r3, [r7, #4]
 142 009a 1B89     		ldrh	r3, [r3, #8]
 143 009c 013B     		sub	r3, r3, #1
 144 009e 9AB2     		uxth	r2, r3
 145 00a0 7B68     		ldr	r3, [r7, #4]
 146 00a2 1A81     		strh	r2, [r3, #8]
 213:../Generated_Code/out_I2C.c ****           I2C_PDD_WriteDataReg(I2C1_BASE_PTR, *(DeviceDataPrv->OutPtrM)++); /* Send character */
 147              		.loc 1 213 0
 148 00a4 574A     		ldr	r2, .L13+4
 149 00a6 7B68     		ldr	r3, [r7, #4]
 150 00a8 DB68     		ldr	r3, [r3, #12]
 151 00aa 1978     		ldrb	r1, [r3]
 152 00ac 1171     		strb	r1, [r2, #4]
 153 00ae 5A1C     		add	r2, r3, #1
 154 00b0 7B68     		ldr	r3, [r7, #4]
 155 00b2 DA60     		str	r2, [r3, #12]
 156 00b4 A1E0     		b	.L1
 157              	.L6:
 214:../Generated_Code/out_I2C.c ****         } else {
 215:../Generated_Code/out_I2C.c ****           if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 158              		.loc 1 215 0
 159 00b6 7B68     		ldr	r3, [r7, #4]
 160 00b8 5B88     		ldrh	r3, [r3, #2]
 161 00ba 002B     		cmp	r3, #0
 162 00bc 1FD0     		beq	.L7
 216:../Generated_Code/out_I2C.c ****             if (DeviceDataPrv->InpLenM == 0x01U) { /* If only one char to receive */
 163              		.loc 1 216 0
 164 00be 7B68     		ldr	r3, [r7, #4]
 165 00c0 5B88     		ldrh	r3, [r3, #2]
 166 00c2 012B     		cmp	r3, #1
 167 00c4 08D1     		bne	.L8
 217:../Generated_Code/out_I2C.c ****               I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_DISABLE); /* then transmit ACK d
 168              		.loc 1 217 0
 169 00c6 4F4B     		ldr	r3, .L13+4
 170 00c8 4E4A     		ldr	r2, .L13+4
 171 00ca 9278     		ldrb	r2, [r2, #2]
 172 00cc D2B2     		uxtb	r2, r2
 173 00ce 0821     		mov	r1, #8
 174 00d0 0A43     		orr	r2, r1
 175 00d2 D2B2     		uxtb	r2, r2
 176 00d4 9A70     		strb	r2, [r3, #2]
 177 00d6 07E0     		b	.L9
 178              	.L8:
 218:../Generated_Code/out_I2C.c ****             } else {
 219:../Generated_Code/out_I2C.c ****               I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_ENABLE); /* else transmit ACK en
 179              		.loc 1 219 0
 180 00d8 4A4B     		ldr	r3, .L13+4
 181 00da 4A4A     		ldr	r2, .L13+4
 182 00dc 9278     		ldrb	r2, [r2, #2]
 183 00de D2B2     		uxtb	r2, r2
 184 00e0 0821     		mov	r1, #8
 185 00e2 8A43     		bic	r2, r1
 186 00e4 D2B2     		uxtb	r2, r2
 187 00e6 9A70     		strb	r2, [r3, #2]
 188              	.L9:
 220:../Generated_Code/out_I2C.c ****             }
 221:../Generated_Code/out_I2C.c ****             I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 189              		.loc 1 221 0
 190 00e8 464B     		ldr	r3, .L13+4
 191 00ea 464A     		ldr	r2, .L13+4
 192 00ec 9278     		ldrb	r2, [r2, #2]
 193 00ee D2B2     		uxtb	r2, r2
 194 00f0 1021     		mov	r1, #16
 195 00f2 8A43     		bic	r2, r1
 196 00f4 D2B2     		uxtb	r2, r2
 197 00f6 9A70     		strb	r2, [r3, #2]
 222:../Generated_Code/out_I2C.c ****             (void)I2C_PDD_ReadDataReg(I2C1_BASE_PTR); /* Dummy read character */
 198              		.loc 1 222 0
 199 00f8 424B     		ldr	r3, .L13+4
 200 00fa 1B79     		ldrb	r3, [r3, #4]
 201 00fc 7DE0     		b	.L1
 202              	.L7:
 223:../Generated_Code/out_I2C.c ****           } else {
 224:../Generated_Code/out_I2C.c ****             DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 203              		.loc 1 224 0
 204 00fe 7B68     		ldr	r3, [r7, #4]
 205 0100 1B78     		ldrb	r3, [r3]
 206 0102 0122     		mov	r2, #1
 207 0104 9343     		bic	r3, r2
 208 0106 DAB2     		uxtb	r2, r3
 209 0108 7B68     		ldr	r3, [r7, #4]
 210 010a 1A70     		strb	r2, [r3]
 225:../Generated_Code/out_I2C.c ****             if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 211              		.loc 1 225 0
 212 010c 7B68     		ldr	r3, [r7, #4]
 213 010e 5B78     		ldrb	r3, [r3, #1]
 214 0110 012B     		cmp	r3, #1
 215 0112 0FD1     		bne	.L10
 226:../Generated_Code/out_I2C.c ****               I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* Switch device to slave m
 216              		.loc 1 226 0
 217 0114 3B4B     		ldr	r3, .L13+4
 218 0116 3B4A     		ldr	r2, .L13+4
 219 0118 9278     		ldrb	r2, [r2, #2]
 220 011a D2B2     		uxtb	r2, r2
 221 011c 2021     		mov	r1, #32
 222 011e 8A43     		bic	r2, r1
 223 0120 D2B2     		uxtb	r2, r2
 224 0122 9A70     		strb	r2, [r3, #2]
 227:../Generated_Code/out_I2C.c ****               I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 225              		.loc 1 227 0
 226 0124 374B     		ldr	r3, .L13+4
 227 0126 374A     		ldr	r2, .L13+4
 228 0128 9278     		ldrb	r2, [r2, #2]
 229 012a D2B2     		uxtb	r2, r2
 230 012c 1021     		mov	r1, #16
 231 012e 8A43     		bic	r2, r1
 232 0130 D2B2     		uxtb	r2, r2
 233 0132 9A70     		strb	r2, [r3, #2]
 234              	.L10:
 228:../Generated_Code/out_I2C.c ****             }
 229:../Generated_Code/out_I2C.c ****             out_I2C_OnMasterBlockSent(DeviceDataPrv->UserData); /* Invoke OnMasterBlockSent event *
 235              		.loc 1 229 0
 236 0134 7B68     		ldr	r3, [r7, #4]
 237 0136 1B69     		ldr	r3, [r3, #16]
 238 0138 181C     		mov	r0, r3
 239 013a FFF7FEFF 		bl	out_I2C_OnMasterBlockSent
 240 013e 5CE0     		b	.L1
 241              	.L3:
 230:../Generated_Code/out_I2C.c ****           }
 231:../Generated_Code/out_I2C.c ****         }
 232:../Generated_Code/out_I2C.c ****       }
 233:../Generated_Code/out_I2C.c ****     } else {
 234:../Generated_Code/out_I2C.c ****       DeviceDataPrv->InpLenM--;        /* Decrease number of chars for the receive */
 242              		.loc 1 234 0
 243 0140 7B68     		ldr	r3, [r7, #4]
 244 0142 5B88     		ldrh	r3, [r3, #2]
 245 0144 013B     		sub	r3, r3, #1
 246 0146 9AB2     		uxth	r2, r3
 247 0148 7B68     		ldr	r3, [r7, #4]
 248 014a 5A80     		strh	r2, [r3, #2]
 235:../Generated_Code/out_I2C.c ****       if (DeviceDataPrv->InpLenM != 0x00U) { /* Is any char. for reception? */
 249              		.loc 1 235 0
 250 014c 7B68     		ldr	r3, [r7, #4]
 251 014e 5B88     		ldrh	r3, [r3, #2]
 252 0150 002B     		cmp	r3, #0
 253 0152 0CD0     		beq	.L11
 236:../Generated_Code/out_I2C.c ****         if (DeviceDataPrv->InpLenM == 0x01U) {
 254              		.loc 1 236 0
 255 0154 7B68     		ldr	r3, [r7, #4]
 256 0156 5B88     		ldrh	r3, [r3, #2]
 257 0158 012B     		cmp	r3, #1
 258 015a 1FD1     		bne	.L12
 237:../Generated_Code/out_I2C.c ****           I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_DISABLE); /* Transmit NACK */
 259              		.loc 1 237 0
 260 015c 294B     		ldr	r3, .L13+4
 261 015e 294A     		ldr	r2, .L13+4
 262 0160 9278     		ldrb	r2, [r2, #2]
 263 0162 D2B2     		uxtb	r2, r2
 264 0164 0821     		mov	r1, #8
 265 0166 0A43     		orr	r2, r1
 266 0168 D2B2     		uxtb	r2, r2
 267 016a 9A70     		strb	r2, [r3, #2]
 268 016c 16E0     		b	.L12
 269              	.L11:
 238:../Generated_Code/out_I2C.c ****         }
 239:../Generated_Code/out_I2C.c ****       } else {
 240:../Generated_Code/out_I2C.c ****         DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Clear flag "busy" */
 270              		.loc 1 240 0
 271 016e 7B68     		ldr	r3, [r7, #4]
 272 0170 1B78     		ldrb	r3, [r3]
 273 0172 0122     		mov	r2, #1
 274 0174 9343     		bic	r3, r2
 275 0176 DAB2     		uxtb	r2, r3
 276 0178 7B68     		ldr	r3, [r7, #4]
 277 017a 1A70     		strb	r2, [r3]
 241:../Generated_Code/out_I2C.c ****         I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_SLAVE_MODE); /* If no, switch device to slave 
 278              		.loc 1 241 0
 279 017c 214B     		ldr	r3, .L13+4
 280 017e 214A     		ldr	r2, .L13+4
 281 0180 9278     		ldrb	r2, [r2, #2]
 282 0182 D2B2     		uxtb	r2, r2
 283 0184 2021     		mov	r1, #32
 284 0186 8A43     		bic	r2, r1
 285 0188 D2B2     		uxtb	r2, r2
 286 018a 9A70     		strb	r2, [r3, #2]
 242:../Generated_Code/out_I2C.c ****         I2C_PDD_EnableTransmitAcknowledge(I2C1_BASE_PTR, PDD_ENABLE); /* Transmit ACK */
 287              		.loc 1 242 0
 288 018c 1D4B     		ldr	r3, .L13+4
 289 018e 1D4A     		ldr	r2, .L13+4
 290 0190 9278     		ldrb	r2, [r2, #2]
 291 0192 D2B2     		uxtb	r2, r2
 292 0194 0821     		mov	r1, #8
 293 0196 8A43     		bic	r2, r1
 294 0198 D2B2     		uxtb	r2, r2
 295 019a 9A70     		strb	r2, [r3, #2]
 296              	.L12:
 243:../Generated_Code/out_I2C.c ****       }
 244:../Generated_Code/out_I2C.c ****       *(DeviceDataPrv->InpPtrM)++ = I2C_PDD_ReadDataReg(I2C1_BASE_PTR); /* Receive character */
 297              		.loc 1 244 0
 298 019c 7B68     		ldr	r3, [r7, #4]
 299 019e 5B68     		ldr	r3, [r3, #4]
 300 01a0 184A     		ldr	r2, .L13+4
 301 01a2 1279     		ldrb	r2, [r2, #4]
 302 01a4 D2B2     		uxtb	r2, r2
 303 01a6 1A70     		strb	r2, [r3]
 304 01a8 5A1C     		add	r2, r3, #1
 305 01aa 7B68     		ldr	r3, [r7, #4]
 306 01ac 5A60     		str	r2, [r3, #4]
 245:../Generated_Code/out_I2C.c ****       if (DeviceDataPrv->InpLenM == 0x00U) { /* Is any char. for reception? */
 307              		.loc 1 245 0
 308 01ae 7B68     		ldr	r3, [r7, #4]
 309 01b0 5B88     		ldrh	r3, [r3, #2]
 310 01b2 002B     		cmp	r3, #0
 311 01b4 21D1     		bne	.L1
 246:../Generated_Code/out_I2C.c ****         out_I2C_OnMasterBlockReceived(DeviceDataPrv->UserData); /* Invoke OnMasterBlockReceived eve
 312              		.loc 1 246 0
 313 01b6 7B68     		ldr	r3, [r7, #4]
 314 01b8 1B69     		ldr	r3, [r3, #16]
 315 01ba 181C     		mov	r0, r3
 316 01bc FFF7FEFF 		bl	out_I2C_OnMasterBlockReceived
 317 01c0 1BE0     		b	.L1
 318              	.L2:
 247:../Generated_Code/out_I2C.c ****       }
 248:../Generated_Code/out_I2C.c ****     }
 249:../Generated_Code/out_I2C.c ****   } else {
 250:../Generated_Code/out_I2C.c ****     if ((Status & I2C_PDD_ARBIT_LOST) != 0x00U) { /* Arbitration lost? */
 319              		.loc 1 250 0
 320 01c2 221C     		mov	r2, r4
 321 01c4 1023     		mov	r3, #16
 322 01c6 1340     		and	r3, r2
 323 01c8 17D0     		beq	.L1
 251:../Generated_Code/out_I2C.c ****       DeviceDataPrv->OutLenM = 0x00U;  /* Any character is not for sent */
 324              		.loc 1 251 0
 325 01ca 7B68     		ldr	r3, [r7, #4]
 326 01cc 0022     		mov	r2, #0
 327 01ce 1A81     		strh	r2, [r3, #8]
 252:../Generated_Code/out_I2C.c ****       DeviceDataPrv->InpLenM = 0x00U;  /* Any character is not for reception */
 328              		.loc 1 252 0
 329 01d0 7B68     		ldr	r3, [r7, #4]
 330 01d2 0022     		mov	r2, #0
 331 01d4 5A80     		strh	r2, [r3, #2]
 253:../Generated_Code/out_I2C.c ****       DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for 
 332              		.loc 1 253 0
 333 01d6 7B68     		ldr	r3, [r7, #4]
 334 01d8 0122     		mov	r2, #1
 335 01da 5A70     		strb	r2, [r3, #1]
 254:../Generated_Code/out_I2C.c ****       DeviceDataPrv->SerFlag &= (uint8_t)~(MASTER_IN_PROGRES); /* Any character is not for sent or 
 336              		.loc 1 254 0
 337 01dc 7B68     		ldr	r3, [r7, #4]
 338 01de 1B78     		ldrb	r3, [r3]
 339 01e0 0122     		mov	r2, #1
 340 01e2 9343     		bic	r3, r2
 341 01e4 DAB2     		uxtb	r2, r3
 342 01e6 7B68     		ldr	r3, [r7, #4]
 343 01e8 1A70     		strb	r2, [r3]
 255:../Generated_Code/out_I2C.c ****       I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_RX_DIRECTION); /* Switch to Rx mode */
 344              		.loc 1 255 0
 345 01ea 064B     		ldr	r3, .L13+4
 346 01ec 054A     		ldr	r2, .L13+4
 347 01ee 9278     		ldrb	r2, [r2, #2]
 348 01f0 D2B2     		uxtb	r2, r2
 349 01f2 1021     		mov	r1, #16
 350 01f4 8A43     		bic	r2, r1
 351 01f6 D2B2     		uxtb	r2, r2
 352 01f8 9A70     		strb	r2, [r3, #2]
 353              	.L1:
 256:../Generated_Code/out_I2C.c ****     }
 257:../Generated_Code/out_I2C.c ****   }
 258:../Generated_Code/out_I2C.c **** }
 354              		.loc 1 258 0
 355 01fa BD46     		mov	sp, r7
 356 01fc 03B0     		add	sp, sp, #12
 357              		@ sp needed for prologue
 358 01fe 90BD     		pop	{r4, r7, pc}
 359              	.L14:
 360              		.align	2
 361              	.L13:
 362 0200 00000000 		.word	INT_I2C1__DEFAULT_RTOS_ISRPARAM
 363 0204 00700640 		.word	1074163712
 364              		.cfi_endproc
 365              	.LFE0:
 367              		.section	.text.out_I2C_Init,"ax",%progbits
 368              		.align	2
 369              		.global	out_I2C_Init
 370              		.code	16
 371              		.thumb_func
 373              	out_I2C_Init:
 374              	.LFB1:
 259:../Generated_Code/out_I2C.c **** 
 260:../Generated_Code/out_I2C.c **** /*
 261:../Generated_Code/out_I2C.c **** ** ===================================================================
 262:../Generated_Code/out_I2C.c **** **     Method      :  out_I2C_Init (component I2C_LDD)
 263:../Generated_Code/out_I2C.c **** */
 264:../Generated_Code/out_I2C.c **** /*!
 265:../Generated_Code/out_I2C.c **** **     @brief
 266:../Generated_Code/out_I2C.c **** **         Initializes the device. Allocates memory for the device data
 267:../Generated_Code/out_I2C.c **** **         structure, allocates interrupt vectors and sets interrupt
 268:../Generated_Code/out_I2C.c **** **         priority, sets pin routing, sets timing, etc.
 269:../Generated_Code/out_I2C.c **** **         If the "Enable in init. code" is set to "yes" value then the
 270:../Generated_Code/out_I2C.c **** **         device is also enabled(see the description of the Enable()
 271:../Generated_Code/out_I2C.c **** **         method). In this case the Enable() method is not necessary
 272:../Generated_Code/out_I2C.c **** **         and needn't to be generated. 
 273:../Generated_Code/out_I2C.c **** **         This method can be called only once. Before the second call
 274:../Generated_Code/out_I2C.c **** **         of Init() the Deinit() must be called first.
 275:../Generated_Code/out_I2C.c **** **     @param
 276:../Generated_Code/out_I2C.c **** **         UserDataPtr     - Pointer to the user or
 277:../Generated_Code/out_I2C.c **** **                           RTOS specific data. This pointer will be
 278:../Generated_Code/out_I2C.c **** **                           passed as an event or callback parameter.
 279:../Generated_Code/out_I2C.c **** **     @return
 280:../Generated_Code/out_I2C.c **** **                         - Pointer to the device data structure. 
 281:../Generated_Code/out_I2C.c **** */
 282:../Generated_Code/out_I2C.c **** /* ===================================================================*/
 283:../Generated_Code/out_I2C.c **** LDD_TDeviceData* out_I2C_Init(LDD_TUserData *UserDataPtr)
 284:../Generated_Code/out_I2C.c **** {
 375              		.loc 1 284 0
 376              		.cfi_startproc
 377 0000 80B5     		push	{r7, lr}
 378              	.LCFI3:
 379              		.cfi_def_cfa_offset 8
 380              		.cfi_offset 7, -8
 381              		.cfi_offset 14, -4
 382 0002 84B0     		sub	sp, sp, #16
 383              	.LCFI4:
 384              		.cfi_def_cfa_offset 24
 385 0004 00AF     		add	r7, sp, #0
 386              	.LCFI5:
 387              		.cfi_def_cfa_register 7
 388 0006 7860     		str	r0, [r7, #4]
 285:../Generated_Code/out_I2C.c ****   /* Allocate HAL device structure */
 286:../Generated_Code/out_I2C.c ****   out_I2C_TDeviceData *DeviceDataPrv;
 287:../Generated_Code/out_I2C.c ****   /* {Default RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer 
 288:../Generated_Code/out_I2C.c ****   DeviceDataPrv = &DeviceDataPrv__DEFAULT_RTOS_ALLOC;
 389              		.loc 1 288 0
 390 0008 384B     		ldr	r3, .L17
 391 000a FB60     		str	r3, [r7, #12]
 289:../Generated_Code/out_I2C.c **** 
 290:../Generated_Code/out_I2C.c ****   DeviceDataPrv->UserData = UserDataPtr; /* Store the RTOS device structure */
 392              		.loc 1 290 0
 393 000c FB68     		ldr	r3, [r7, #12]
 394 000e 7A68     		ldr	r2, [r7, #4]
 395 0010 1A61     		str	r2, [r3, #16]
 291:../Generated_Code/out_I2C.c **** 
 292:../Generated_Code/out_I2C.c ****   /* Allocate interrupt vector */
 293:../Generated_Code/out_I2C.c ****   /* {Default RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the glo
 294:../Generated_Code/out_I2C.c ****   INT_I2C1__DEFAULT_RTOS_ISRPARAM = DeviceDataPrv;
 396              		.loc 1 294 0
 397 0012 374B     		ldr	r3, .L17+4
 398 0014 FA68     		ldr	r2, [r7, #12]
 399 0016 1A60     		str	r2, [r3]
 295:../Generated_Code/out_I2C.c ****   DeviceDataPrv->SerFlag = 0x00U;      /* Reset all flags */
 400              		.loc 1 295 0
 401 0018 FB68     		ldr	r3, [r7, #12]
 402 001a 0022     		mov	r2, #0
 403 001c 1A70     		strb	r2, [r3]
 296:../Generated_Code/out_I2C.c ****   DeviceDataPrv->SendStop = LDD_I2C_SEND_STOP; /* Set variable for sending stop condition (for mast
 404              		.loc 1 296 0
 405 001e FB68     		ldr	r3, [r7, #12]
 406 0020 0122     		mov	r2, #1
 407 0022 5A70     		strb	r2, [r3, #1]
 297:../Generated_Code/out_I2C.c ****   DeviceDataPrv->InpLenM = 0x00U;      /* Set zero counter of data of reception */
 408              		.loc 1 297 0
 409 0024 FB68     		ldr	r3, [r7, #12]
 410 0026 0022     		mov	r2, #0
 411 0028 5A80     		strh	r2, [r3, #2]
 298:../Generated_Code/out_I2C.c ****   DeviceDataPrv->OutLenM = 0x00U;      /* Set zero counter of data of transmission */
 412              		.loc 1 298 0
 413 002a FB68     		ldr	r3, [r7, #12]
 414 002c 0022     		mov	r2, #0
 415 002e 1A81     		strh	r2, [r3, #8]
 299:../Generated_Code/out_I2C.c ****   /* SIM_SCGC4: I2C1=1 */
 300:../Generated_Code/out_I2C.c ****   SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK;
 416              		.loc 1 300 0
 417 0030 304A     		ldr	r2, .L17+8
 418 0032 3049     		ldr	r1, .L17+8
 419 0034 304B     		ldr	r3, .L17+12
 420 0036 CB58     		ldr	r3, [r1, r3]
 421 0038 8021     		mov	r1, #128
 422 003a 1943     		orr	r1, r3
 423 003c 2E4B     		ldr	r3, .L17+12
 424 003e D150     		str	r1, [r2, r3]
 301:../Generated_Code/out_I2C.c ****   /* I2C1_C1: IICEN=0,IICIE=0,MST=0,TX=0,TXAK=0,RSTA=0,WUEN=0,DMAEN=0 */
 302:../Generated_Code/out_I2C.c ****   I2C1_C1 = 0x00U;                     /* Clear control register */
 425              		.loc 1 302 0
 426 0040 2E4B     		ldr	r3, .L17+16
 427 0042 0022     		mov	r2, #0
 428 0044 9A70     		strb	r2, [r3, #2]
 303:../Generated_Code/out_I2C.c ****   /* I2C1_FLT: SHEN=0,STOPF=1,STOPIE=0,FLT=0 */
 304:../Generated_Code/out_I2C.c ****   I2C1_FLT = (I2C_FLT_STOPF_MASK | I2C_FLT_FLT(0x00)); /* Clear bus status interrupt flags */
 429              		.loc 1 304 0
 430 0046 2D4B     		ldr	r3, .L17+16
 431 0048 4022     		mov	r2, #64
 432 004a 9A71     		strb	r2, [r3, #6]
 305:../Generated_Code/out_I2C.c ****   /* I2C1_S: TCF=0,IAAS=0,BUSY=0,ARBL=0,RAM=0,SRW=0,IICIF=1,RXAK=0 */
 306:../Generated_Code/out_I2C.c ****   I2C1_S = I2C_S_IICIF_MASK;           /* Clear interrupt flag */
 433              		.loc 1 306 0
 434 004c 2B4B     		ldr	r3, .L17+16
 435 004e 0222     		mov	r2, #2
 436 0050 DA70     		strb	r2, [r3, #3]
 307:../Generated_Code/out_I2C.c ****   /* PORTE_PCR0: ISF=0,MUX=6 */
 308:../Generated_Code/out_I2C.c ****   PORTE_PCR0 = (uint32_t)((PORTE_PCR0 & (uint32_t)~(uint32_t)(
 437              		.loc 1 308 0
 438 0052 2B4B     		ldr	r3, .L17+20
 439 0054 2A4A     		ldr	r2, .L17+20
 440 0056 1168     		ldr	r1, [r2]
 441 0058 2A4A     		ldr	r2, .L17+24
 442 005a 0A40     		and	r2, r1
 443 005c C021     		mov	r1, #192
 444 005e C900     		lsl	r1, r1, #3
 445 0060 0A43     		orr	r2, r1
 446 0062 1A60     		str	r2, [r3]
 309:../Generated_Code/out_I2C.c ****                 PORT_PCR_ISF_MASK |
 310:../Generated_Code/out_I2C.c ****                 PORT_PCR_MUX(0x01)
 311:../Generated_Code/out_I2C.c ****                )) | (uint32_t)(
 312:../Generated_Code/out_I2C.c ****                 PORT_PCR_MUX(0x06)
 313:../Generated_Code/out_I2C.c ****                ));
 314:../Generated_Code/out_I2C.c ****   /* PORTE_PCR1: ISF=0,MUX=6 */
 315:../Generated_Code/out_I2C.c ****   PORTE_PCR1 = (uint32_t)((PORTE_PCR1 & (uint32_t)~(uint32_t)(
 447              		.loc 1 315 0
 448 0064 264B     		ldr	r3, .L17+20
 449 0066 264A     		ldr	r2, .L17+20
 450 0068 5168     		ldr	r1, [r2, #4]
 451 006a 264A     		ldr	r2, .L17+24
 452 006c 0A40     		and	r2, r1
 453 006e C021     		mov	r1, #192
 454 0070 C900     		lsl	r1, r1, #3
 455 0072 0A43     		orr	r2, r1
 456 0074 5A60     		str	r2, [r3, #4]
 316:../Generated_Code/out_I2C.c ****                 PORT_PCR_ISF_MASK |
 317:../Generated_Code/out_I2C.c ****                 PORT_PCR_MUX(0x01)
 318:../Generated_Code/out_I2C.c ****                )) | (uint32_t)(
 319:../Generated_Code/out_I2C.c ****                 PORT_PCR_MUX(0x06)
 320:../Generated_Code/out_I2C.c ****                ));
 321:../Generated_Code/out_I2C.c ****   /* NVIC_IPR2: PRI_9=0x80 */
 322:../Generated_Code/out_I2C.c ****   NVIC_IPR2 = (uint32_t)((NVIC_IPR2 & (uint32_t)~(uint32_t)(
 457              		.loc 1 322 0
 458 0076 244A     		ldr	r2, .L17+28
 459 0078 2349     		ldr	r1, .L17+28
 460 007a C223     		mov	r3, #194
 461 007c 9B00     		lsl	r3, r3, #2
 462 007e C958     		ldr	r1, [r1, r3]
 463 0080 224B     		ldr	r3, .L17+32
 464 0082 0B40     		and	r3, r1
 465 0084 8021     		mov	r1, #128
 466 0086 0902     		lsl	r1, r1, #8
 467 0088 1943     		orr	r1, r3
 468 008a C223     		mov	r3, #194
 469 008c 9B00     		lsl	r3, r3, #2
 470 008e D150     		str	r1, [r2, r3]
 323:../Generated_Code/out_I2C.c ****                NVIC_IP_PRI_9(0x7F)
 324:../Generated_Code/out_I2C.c ****               )) | (uint32_t)(
 325:../Generated_Code/out_I2C.c ****                NVIC_IP_PRI_9(0x80)
 326:../Generated_Code/out_I2C.c ****               ));
 327:../Generated_Code/out_I2C.c ****   /* NVIC_ISER: SETENA|=0x0200 */
 328:../Generated_Code/out_I2C.c ****   NVIC_ISER |= NVIC_ISER_SETENA(0x0200);
 471              		.loc 1 328 0
 472 0090 1D4B     		ldr	r3, .L17+28
 473 0092 1D4A     		ldr	r2, .L17+28
 474 0094 1268     		ldr	r2, [r2]
 475 0096 8021     		mov	r1, #128
 476 0098 8900     		lsl	r1, r1, #2
 477 009a 0A43     		orr	r2, r1
 478 009c 1A60     		str	r2, [r3]
 329:../Generated_Code/out_I2C.c ****   /* I2C1_C2: GCAEN=0,ADEXT=0,HDRS=0,SBRC=0,RMEN=0,AD=0 */
 330:../Generated_Code/out_I2C.c ****   I2C1_C2 = I2C_C2_AD(0x00);
 479              		.loc 1 330 0
 480 009e 174B     		ldr	r3, .L17+16
 481 00a0 0022     		mov	r2, #0
 482 00a2 5A71     		strb	r2, [r3, #5]
 331:../Generated_Code/out_I2C.c ****   /* I2C1_FLT: SHEN=0,STOPF=0,STOPIE=0,FLT=0 */
 332:../Generated_Code/out_I2C.c ****   I2C1_FLT = I2C_FLT_FLT(0x00);        /* Set glitch filter register */
 483              		.loc 1 332 0
 484 00a4 154B     		ldr	r3, .L17+16
 485 00a6 0022     		mov	r2, #0
 486 00a8 9A71     		strb	r2, [r3, #6]
 333:../Generated_Code/out_I2C.c ****   /* I2C1_SMB: FACK=0,ALERTEN=0,SIICAEN=0,TCKSEL=0,SLTF=1,SHTF1=0,SHTF2=0,SHTF2IE=0 */
 334:../Generated_Code/out_I2C.c ****   I2C1_SMB = I2C_SMB_SLTF_MASK;
 487              		.loc 1 334 0
 488 00aa 144B     		ldr	r3, .L17+16
 489 00ac 0822     		mov	r2, #8
 490 00ae 1A72     		strb	r2, [r3, #8]
 335:../Generated_Code/out_I2C.c ****   /* I2C1_F: MULT=0,ICR=0x25 */
 336:../Generated_Code/out_I2C.c ****   I2C1_F = (I2C_F_MULT(0x00) | I2C_F_ICR(0x25)); /* Set prescaler bits */
 491              		.loc 1 336 0
 492 00b0 124B     		ldr	r3, .L17+16
 493 00b2 2522     		mov	r2, #37
 494 00b4 5A70     		strb	r2, [r3, #1]
 337:../Generated_Code/out_I2C.c ****   I2C_PDD_EnableDevice(I2C1_BASE_PTR, PDD_ENABLE); /* Enable device */
 495              		.loc 1 337 0
 496 00b6 114B     		ldr	r3, .L17+16
 497 00b8 104A     		ldr	r2, .L17+16
 498 00ba 9278     		ldrb	r2, [r2, #2]
 499 00bc D2B2     		uxtb	r2, r2
 500 00be D2B2     		uxtb	r2, r2
 501 00c0 8021     		mov	r1, #128
 502 00c2 4942     		neg	r1, r1
 503 00c4 0A43     		orr	r2, r1
 504 00c6 D2B2     		uxtb	r2, r2
 505 00c8 D2B2     		uxtb	r2, r2
 506 00ca 9A70     		strb	r2, [r3, #2]
 338:../Generated_Code/out_I2C.c ****   I2C_PDD_EnableInterrupt(I2C1_BASE_PTR); /* Enable interrupt */
 507              		.loc 1 338 0
 508 00cc 0B4B     		ldr	r3, .L17+16
 509 00ce 0B4A     		ldr	r2, .L17+16
 510 00d0 9278     		ldrb	r2, [r2, #2]
 511 00d2 D2B2     		uxtb	r2, r2
 512 00d4 4021     		mov	r1, #64
 513 00d6 0A43     		orr	r2, r1
 514 00d8 D2B2     		uxtb	r2, r2
 515 00da 9A70     		strb	r2, [r3, #2]
 339:../Generated_Code/out_I2C.c ****   /* Registration of the device structure */
 340:../Generated_Code/out_I2C.c ****   PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_out_I2C_ID,DeviceDataPrv);
 516              		.loc 1 340 0
 517 00dc 0C4B     		ldr	r3, .L17+36
 518 00de FA68     		ldr	r2, [r7, #12]
 519 00e0 5A61     		str	r2, [r3, #20]
 341:../Generated_Code/out_I2C.c ****   return ((LDD_TDeviceData *)DeviceDataPrv); /* Return pointer to the data data structure */
 520              		.loc 1 341 0
 521 00e2 FB68     		ldr	r3, [r7, #12]
 342:../Generated_Code/out_I2C.c **** }
 522              		.loc 1 342 0
 523 00e4 181C     		mov	r0, r3
 524 00e6 BD46     		mov	sp, r7
 525 00e8 04B0     		add	sp, sp, #16
 526              		@ sp needed for prologue
 527 00ea 80BD     		pop	{r7, pc}
 528              	.L18:
 529              		.align	2
 530              	.L17:
 531 00ec 00000000 		.word	DeviceDataPrv__DEFAULT_RTOS_ALLOC
 532 00f0 00000000 		.word	INT_I2C1__DEFAULT_RTOS_ISRPARAM
 533 00f4 00700440 		.word	1074032640
 534 00f8 34100000 		.word	4148
 535 00fc 00700640 		.word	1074163712
 536 0100 00D00440 		.word	1074057216
 537 0104 FFF8FFFE 		.word	-16779009
 538 0108 00E100E0 		.word	-536813312
 539 010c FF00FFFF 		.word	-65281
 540 0110 00000000 		.word	PE_LDD_DeviceDataList
 541              		.cfi_endproc
 542              	.LFE1:
 544              		.section	.text.out_I2C_MasterSendBlock,"ax",%progbits
 545              		.align	2
 546              		.global	out_I2C_MasterSendBlock
 547              		.code	16
 548              		.thumb_func
 550              	out_I2C_MasterSendBlock:
 551              	.LFB2:
 343:../Generated_Code/out_I2C.c **** 
 344:../Generated_Code/out_I2C.c **** /*
 345:../Generated_Code/out_I2C.c **** ** ===================================================================
 346:../Generated_Code/out_I2C.c **** **     Method      :  out_I2C_MasterSendBlock (component I2C_LDD)
 347:../Generated_Code/out_I2C.c **** */
 348:../Generated_Code/out_I2C.c **** /*!
 349:../Generated_Code/out_I2C.c **** **     @brief
 350:../Generated_Code/out_I2C.c **** **         This method writes one (7-bit addressing) or two (10-bit
 351:../Generated_Code/out_I2C.c **** **         addressing) slave address bytes inclusive of R/W bit = 0 to
 352:../Generated_Code/out_I2C.c **** **         the I2C bus and then writes the block of characters to the
 353:../Generated_Code/out_I2C.c **** **         bus. The slave address must be specified before, by the
 354:../Generated_Code/out_I2C.c **** **         "SelectSlaveDevice" method or in component initialization
 355:../Generated_Code/out_I2C.c **** **         section, "Target slave address init" property. If the method
 356:../Generated_Code/out_I2C.c **** **         returns ERR_OK, it doesn't mean that transmission was
 357:../Generated_Code/out_I2C.c **** **         successful. The state of transmission is detectable by means
 358:../Generated_Code/out_I2C.c **** **         of events (OnMasterSendComplete or OnError). Data to be sent
 359:../Generated_Code/out_I2C.c **** **         are not copied to an internal buffer and remains in the
 360:../Generated_Code/out_I2C.c **** **         original location. Therefore the content of the buffer
 361:../Generated_Code/out_I2C.c **** **         should not be changed until the transmission is complete.
 362:../Generated_Code/out_I2C.c **** **         Event "OnMasterBlockSent"can be used to detect the end of
 363:../Generated_Code/out_I2C.c **** **         the transmission. This method is available only for the
 364:../Generated_Code/out_I2C.c **** **         MASTER or MASTER - SLAVE mode.
 365:../Generated_Code/out_I2C.c **** **     @param
 366:../Generated_Code/out_I2C.c **** **         DeviceDataPtr   - Device data structure
 367:../Generated_Code/out_I2C.c **** **                           pointer returned by <Init> method.
 368:../Generated_Code/out_I2C.c **** **     @param
 369:../Generated_Code/out_I2C.c **** **         BufferPtr       - Pointer to the block of data
 370:../Generated_Code/out_I2C.c **** **                           to send.
 371:../Generated_Code/out_I2C.c **** **     @param
 372:../Generated_Code/out_I2C.c **** **         Size            - Size of the data block.
 373:../Generated_Code/out_I2C.c **** **     @param
 374:../Generated_Code/out_I2C.c **** **         SendStop        - Parameter for generating I2C
 375:../Generated_Code/out_I2C.c **** **                           Stop condition
 376:../Generated_Code/out_I2C.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 377:../Generated_Code/out_I2C.c **** **                           generated on end transmission.
 378:../Generated_Code/out_I2C.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 379:../Generated_Code/out_I2C.c **** **                           generated on end transmission.
 380:../Generated_Code/out_I2C.c **** **     @return
 381:../Generated_Code/out_I2C.c **** **                         - Error code, possible codes:
 382:../Generated_Code/out_I2C.c **** **                           ERR_OK - OK
 383:../Generated_Code/out_I2C.c **** **                           ERR_DISABLED -  Device is disabled
 384:../Generated_Code/out_I2C.c **** **                           ERR_SPEED - This device does not work in
 385:../Generated_Code/out_I2C.c **** **                           the active clock configuration
 386:../Generated_Code/out_I2C.c **** **                           ERR_BUSY - The I2C device is now running
 387:../Generated_Code/out_I2C.c **** */
 388:../Generated_Code/out_I2C.c **** /* ===================================================================*/
 389:../Generated_Code/out_I2C.c **** LDD_TError out_I2C_MasterSendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C_TS
 390:../Generated_Code/out_I2C.c **** {
 552              		.loc 1 390 0
 553              		.cfi_startproc
 554 0000 80B5     		push	{r7, lr}
 555              	.LCFI6:
 556              		.cfi_def_cfa_offset 8
 557              		.cfi_offset 7, -8
 558              		.cfi_offset 14, -4
 559 0002 86B0     		sub	sp, sp, #24
 560              	.LCFI7:
 561              		.cfi_def_cfa_offset 32
 562 0004 00AF     		add	r7, sp, #0
 563              	.LCFI8:
 564              		.cfi_def_cfa_register 7
 565 0006 F860     		str	r0, [r7, #12]
 566 0008 B960     		str	r1, [r7, #8]
 567 000a 111C     		mov	r1, r2
 568 000c 1A1C     		mov	r2, r3
 569 000e BB1D     		add	r3, r7, #6
 570 0010 1980     		strh	r1, [r3]
 571 0012 7B1D     		add	r3, r7, #5
 572 0014 1A70     		strb	r2, [r3]
 391:../Generated_Code/out_I2C.c ****   out_I2C_TDeviceData *DeviceDataPrv = (out_I2C_TDeviceData *)DeviceDataPtr;
 573              		.loc 1 391 0
 574 0016 FB68     		ldr	r3, [r7, #12]
 575 0018 7B61     		str	r3, [r7, #20]
 392:../Generated_Code/out_I2C.c **** 
 393:../Generated_Code/out_I2C.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 576              		.loc 1 393 0
 577 001a BB1D     		add	r3, r7, #6
 578 001c 1B88     		ldrh	r3, [r3]
 579 001e 002B     		cmp	r3, #0
 580 0020 01D1     		bne	.L20
 394:../Generated_Code/out_I2C.c ****     return ERR_OK;                     /* If zero then OK */
 581              		.loc 1 394 0
 582 0022 0023     		mov	r3, #0
 583 0024 7FE0     		b	.L21
 584              	.L20:
 395:../Generated_Code/out_I2C.c ****   }
 396:../Generated_Code/out_I2C.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 585              		.loc 1 396 0
 586 0026 7B69     		ldr	r3, [r7, #20]
 587 0028 5B78     		ldrb	r3, [r3, #1]
 588 002a 012B     		cmp	r3, #1
 589 002c 12D1     		bne	.L22
 397:../Generated_Code/out_I2C.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 590              		.loc 1 397 0
 591 002e 404B     		ldr	r3, .L30
 592 0030 DB78     		ldrb	r3, [r3, #3]
 593 0032 DBB2     		uxtb	r3, r3
 594 0034 1A1C     		mov	r2, r3
 595 0036 2023     		mov	r3, #32
 596 0038 1340     		and	r3, r2
 597 003a 09D1     		bne	.L23
 398:../Generated_Code/out_I2C.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 598              		.loc 1 398 0
 599 003c 7B69     		ldr	r3, [r7, #20]
 600 003e 1B78     		ldrb	r3, [r3]
 601 0040 1A1C     		mov	r2, r3
 602 0042 0123     		mov	r3, #1
 603 0044 1340     		and	r3, r2
 397:../Generated_Code/out_I2C.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 604              		.loc 1 397 0
 605 0046 03D1     		bne	.L23
 399:../Generated_Code/out_I2C.c ****        (DeviceDataPrv->OutLenM != 0x00U))  {
 606              		.loc 1 399 0
 607 0048 7B69     		ldr	r3, [r7, #20]
 608 004a 1B89     		ldrh	r3, [r3, #8]
 398:../Generated_Code/out_I2C.c ****        ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 609              		.loc 1 398 0
 610 004c 002B     		cmp	r3, #0
 611 004e 0DD0     		beq	.L24
 612              	.L23:
 400:../Generated_Code/out_I2C.c ****       return ERR_BUSY;                 /* If yes then error */
 613              		.loc 1 400 0
 614 0050 0823     		mov	r3, #8
 615 0052 68E0     		b	.L21
 616              	.L22:
 401:../Generated_Code/out_I2C.c ****     }
 402:../Generated_Code/out_I2C.c ****   } else {
 403:../Generated_Code/out_I2C.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 617              		.loc 1 403 0
 618 0054 7B69     		ldr	r3, [r7, #20]
 619 0056 1B78     		ldrb	r3, [r3]
 620 0058 1A1C     		mov	r2, r3
 621 005a 0123     		mov	r3, #1
 622 005c 1340     		and	r3, r2
 623 005e 03D1     		bne	.L25
 404:../Generated_Code/out_I2C.c ****       (DeviceDataPrv->OutLenM != 0x00U))  {
 624              		.loc 1 404 0
 625 0060 7B69     		ldr	r3, [r7, #20]
 626 0062 1B89     		ldrh	r3, [r3, #8]
 403:../Generated_Code/out_I2C.c ****     if (((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 627              		.loc 1 403 0
 628 0064 002B     		cmp	r3, #0
 629 0066 01D0     		beq	.L24
 630              	.L25:
 405:../Generated_Code/out_I2C.c ****       return ERR_BUSY;                 /* If yes then error */
 631              		.loc 1 405 0
 632 0068 0823     		mov	r3, #8
 633 006a 5CE0     		b	.L21
 634              	.L24:
 635              	.LBB2:
 406:../Generated_Code/out_I2C.c ****     }
 407:../Generated_Code/out_I2C.c ****   }
 408:../Generated_Code/out_I2C.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 409:../Generated_Code/out_I2C.c ****   EnterCritical();
 636              		.loc 1 409 0
 637 006c 3B1C     		mov	r3, r7
 638 006e 1333     		add	r3, r3, #19
 639              	@ 409 "../Generated_Code/out_I2C.c" 1
 640 0070 EFF31080 		MRS R0, PRIMASK
 641 0074 72B6     		CPSID i
 642 0076 1870     		STRB R0, [r3]
 643              	@ 0 "" 2
 644              		.code	16
 645 0078 2E4B     		ldr	r3, .L30+4
 646 007a 1B78     		ldrb	r3, [r3]
 647 007c DBB2     		uxtb	r3, r3
 648 007e 0133     		add	r3, r3, #1
 649 0080 DBB2     		uxtb	r3, r3
 650 0082 2C4A     		ldr	r2, .L30+4
 651 0084 191C     		add	r1, r3, #0
 652 0086 1170     		strb	r1, [r2]
 653 0088 012B     		cmp	r3, #1
 654 008a 04D1     		bne	.L26
 655              		.loc 1 409 0 is_stmt 0
 656 008c 3B1C     		mov	r3, r7
 657 008e 1333     		add	r3, r3, #19
 658 0090 1A78     		ldrb	r2, [r3]
 659 0092 294B     		ldr	r3, .L30+8
 660 0094 1A70     		strb	r2, [r3]
 661              	.L26:
 662              	.LBE2:
 410:../Generated_Code/out_I2C.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 663              		.loc 1 410 0 is_stmt 1
 664 0096 7B69     		ldr	r3, [r7, #20]
 665 0098 1B78     		ldrb	r3, [r3]
 666 009a 0122     		mov	r2, #1
 667 009c 1343     		orr	r3, r2
 668 009e DAB2     		uxtb	r2, r3
 669 00a0 7B69     		ldr	r3, [r7, #20]
 670 00a2 1A70     		strb	r2, [r3]
 411:../Generated_Code/out_I2C.c ****   DeviceDataPrv->OutPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for transmitting */
 671              		.loc 1 411 0
 672 00a4 7B69     		ldr	r3, [r7, #20]
 673 00a6 BA68     		ldr	r2, [r7, #8]
 674 00a8 DA60     		str	r2, [r3, #12]
 412:../Generated_Code/out_I2C.c ****   DeviceDataPrv->OutLenM = Size;       /* Set the counter of output bufer's content */
 675              		.loc 1 412 0
 676 00aa 7B69     		ldr	r3, [r7, #20]
 677 00ac BA1D     		add	r2, r7, #6
 678 00ae 1288     		ldrh	r2, [r2]
 679 00b0 1A81     		strh	r2, [r3, #8]
 413:../Generated_Code/out_I2C.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 680              		.loc 1 413 0
 681 00b2 7B69     		ldr	r3, [r7, #20]
 682 00b4 7A1D     		add	r2, r7, #5
 683 00b6 1278     		ldrb	r2, [r2]
 684 00b8 5A70     		strb	r2, [r3, #1]
 414:../Generated_Code/out_I2C.c ****   I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 685              		.loc 1 414 0
 686 00ba 1D4B     		ldr	r3, .L30
 687 00bc 1C4A     		ldr	r2, .L30
 688 00be 9278     		ldrb	r2, [r2, #2]
 689 00c0 D2B2     		uxtb	r2, r2
 690 00c2 D2B2     		uxtb	r2, r2
 691 00c4 1021     		mov	r1, #16
 692 00c6 0A43     		orr	r2, r1
 693 00c8 D2B2     		uxtb	r2, r2
 694 00ca D2B2     		uxtb	r2, r2
 695 00cc 9A70     		strb	r2, [r3, #2]
 415:../Generated_Code/out_I2C.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 696              		.loc 1 415 0
 697 00ce 184B     		ldr	r3, .L30
 698 00d0 9B78     		ldrb	r3, [r3, #2]
 699 00d2 DBB2     		uxtb	r3, r3
 700 00d4 1A1C     		mov	r2, r3
 701 00d6 2023     		mov	r3, #32
 702 00d8 1340     		and	r3, r2
 703 00da 08D0     		beq	.L27
 416:../Generated_Code/out_I2C.c ****     I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* If yes then repeat start cycle generated */
 704              		.loc 1 416 0
 705 00dc 144B     		ldr	r3, .L30
 706 00de 144A     		ldr	r2, .L30
 707 00e0 9278     		ldrb	r2, [r2, #2]
 708 00e2 D2B2     		uxtb	r2, r2
 709 00e4 0421     		mov	r1, #4
 710 00e6 0A43     		orr	r2, r1
 711 00e8 D2B2     		uxtb	r2, r2
 712 00ea 9A70     		strb	r2, [r3, #2]
 713 00ec 09E0     		b	.L28
 714              	.L27:
 417:../Generated_Code/out_I2C.c ****   } else {
 418:../Generated_Code/out_I2C.c ****     I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 715              		.loc 1 418 0
 716 00ee 104B     		ldr	r3, .L30
 717 00f0 0F4A     		ldr	r2, .L30
 718 00f2 9278     		ldrb	r2, [r2, #2]
 719 00f4 D2B2     		uxtb	r2, r2
 720 00f6 D2B2     		uxtb	r2, r2
 721 00f8 2021     		mov	r1, #32
 722 00fa 0A43     		orr	r2, r1
 723 00fc D2B2     		uxtb	r2, r2
 724 00fe D2B2     		uxtb	r2, r2
 725 0100 9A70     		strb	r2, [r3, #2]
 726              	.L28:
 419:../Generated_Code/out_I2C.c ****   }
 420:../Generated_Code/out_I2C.c ****   I2C_PDD_WriteDataReg(I2C1_BASE_PTR, 0x00U); /* Send slave address */
 727              		.loc 1 420 0
 728 0102 0B4B     		ldr	r3, .L30
 729 0104 0022     		mov	r2, #0
 730 0106 1A71     		strb	r2, [r3, #4]
 421:../Generated_Code/out_I2C.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 422:../Generated_Code/out_I2C.c ****   ExitCritical();
 731              		.loc 1 422 0
 732 0108 0A4B     		ldr	r3, .L30+4
 733 010a 1B78     		ldrb	r3, [r3]
 734 010c DBB2     		uxtb	r3, r3
 735 010e 013B     		sub	r3, r3, #1
 736 0110 DBB2     		uxtb	r3, r3
 737 0112 084A     		ldr	r2, .L30+4
 738 0114 191C     		add	r1, r3, #0
 739 0116 1170     		strb	r1, [r2]
 740 0118 002B     		cmp	r3, #0
 741 011a 03D1     		bne	.L29
 742              		.loc 1 422 0 is_stmt 0
 743 011c 064B     		ldr	r3, .L30+8
 744              	@ 422 "../Generated_Code/out_I2C.c" 1
 745 011e 1878     		ldrb r0, [r3]
 746 0120 80F31088 		msr PRIMASK,r0;
 747              		
 748              	@ 0 "" 2
 749              		.code	16
 750              	.L29:
 423:../Generated_Code/out_I2C.c ****   return ERR_OK;                       /* OK */
 751              		.loc 1 423 0 is_stmt 1
 752 0124 0023     		mov	r3, #0
 753              	.L21:
 424:../Generated_Code/out_I2C.c **** }
 754              		.loc 1 424 0
 755 0126 181C     		mov	r0, r3
 756 0128 BD46     		mov	sp, r7
 757 012a 06B0     		add	sp, sp, #24
 758              		@ sp needed for prologue
 759 012c 80BD     		pop	{r7, pc}
 760              	.L31:
 761 012e C046     		.align	2
 762              	.L30:
 763 0130 00700640 		.word	1074163712
 764 0134 00000000 		.word	SR_lock
 765 0138 00000000 		.word	SR_reg
 766              		.cfi_endproc
 767              	.LFE2:
 769              		.section	.text.out_I2C_MasterReceiveBlock,"ax",%progbits
 770              		.align	2
 771              		.global	out_I2C_MasterReceiveBlock
 772              		.code	16
 773              		.thumb_func
 775              	out_I2C_MasterReceiveBlock:
 776              	.LFB3:
 425:../Generated_Code/out_I2C.c **** 
 426:../Generated_Code/out_I2C.c **** /*
 427:../Generated_Code/out_I2C.c **** ** ===================================================================
 428:../Generated_Code/out_I2C.c **** **     Method      :  out_I2C_MasterReceiveBlock (component I2C_LDD)
 429:../Generated_Code/out_I2C.c **** */
 430:../Generated_Code/out_I2C.c **** /*!
 431:../Generated_Code/out_I2C.c **** **     @brief
 432:../Generated_Code/out_I2C.c **** **         This method writes one (7-bit addressing) or two (10-bit
 433:../Generated_Code/out_I2C.c **** **         addressing) slave address bytes inclusive of R/W bit = 1 to
 434:../Generated_Code/out_I2C.c **** **         the I2C bus and then receives the block of characters from
 435:../Generated_Code/out_I2C.c **** **         the bus. The slave address must be specified before, by the
 436:../Generated_Code/out_I2C.c **** **         "SelectSlaveDevice" method or in component initialization
 437:../Generated_Code/out_I2C.c **** **         section, "Target slave address init" property. If the method
 438:../Generated_Code/out_I2C.c **** **         returns ERR_OK, it doesn't mean that reception was
 439:../Generated_Code/out_I2C.c **** **         successful. The state of reception is detectable by means of
 440:../Generated_Code/out_I2C.c **** **         events (OnMasterSendComplete  or OnError). Data to be
 441:../Generated_Code/out_I2C.c **** **         received are not copied to an internal buffer and remains in
 442:../Generated_Code/out_I2C.c **** **         the original location. Therefore the content of the buffer
 443:../Generated_Code/out_I2C.c **** **         should not be changed until the transmission is complete.
 444:../Generated_Code/out_I2C.c **** **         Event "OnMasterBlockReceived"can be used to detect the end
 445:../Generated_Code/out_I2C.c **** **         of the reception. This method is available only for the
 446:../Generated_Code/out_I2C.c **** **         MASTER or MASTER - SLAVE mode.
 447:../Generated_Code/out_I2C.c **** **     @param
 448:../Generated_Code/out_I2C.c **** **         DeviceDataPtr   - Device data structure
 449:../Generated_Code/out_I2C.c **** **                           pointer returned by <Init> method.
 450:../Generated_Code/out_I2C.c **** **     @param
 451:../Generated_Code/out_I2C.c **** **         BufferPtr       - Pointer to a buffer where
 452:../Generated_Code/out_I2C.c **** **                           received characters will be stored.
 453:../Generated_Code/out_I2C.c **** **     @param
 454:../Generated_Code/out_I2C.c **** **         Size            - The size of the block.
 455:../Generated_Code/out_I2C.c **** **     @param
 456:../Generated_Code/out_I2C.c **** **         SendStop        - Parameter for generating I2C
 457:../Generated_Code/out_I2C.c **** **                           Stop condition
 458:../Generated_Code/out_I2C.c **** **                           LDD_I2C_SEND_STOP - Stop condition is
 459:../Generated_Code/out_I2C.c **** **                           generated on end transmission.
 460:../Generated_Code/out_I2C.c **** **                           LDD_I2C_NO_SEND_STOP - Stop condition isn't
 461:../Generated_Code/out_I2C.c **** **                           generated on end transmission.
 462:../Generated_Code/out_I2C.c **** **     @return
 463:../Generated_Code/out_I2C.c **** **                         - Error code, possible codes:
 464:../Generated_Code/out_I2C.c **** **                           ERR_OK - OK
 465:../Generated_Code/out_I2C.c **** **                           ERR_DISABLED -  Device is disabled
 466:../Generated_Code/out_I2C.c **** **                           ERR_SPEED - This device does not work in
 467:../Generated_Code/out_I2C.c **** **                           the active clock configuration
 468:../Generated_Code/out_I2C.c **** **                           ERR_BUSY - The master device is busy
 469:../Generated_Code/out_I2C.c **** **                           ERR_NOTAVAIL - It is not possible to
 470:../Generated_Code/out_I2C.c **** **                           receive data if general call address is set.
 471:../Generated_Code/out_I2C.c **** **                           ERR_PARAM_MODE -  Stop condition isn't
 472:../Generated_Code/out_I2C.c **** **                           possible generated on end transmission.
 473:../Generated_Code/out_I2C.c **** */
 474:../Generated_Code/out_I2C.c **** /* ===================================================================*/
 475:../Generated_Code/out_I2C.c **** LDD_TError out_I2C_MasterReceiveBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, LDD_I2C
 476:../Generated_Code/out_I2C.c **** {
 777              		.loc 1 476 0
 778              		.cfi_startproc
 779 0000 80B5     		push	{r7, lr}
 780              	.LCFI9:
 781              		.cfi_def_cfa_offset 8
 782              		.cfi_offset 7, -8
 783              		.cfi_offset 14, -4
 784 0002 86B0     		sub	sp, sp, #24
 785              	.LCFI10:
 786              		.cfi_def_cfa_offset 32
 787 0004 00AF     		add	r7, sp, #0
 788              	.LCFI11:
 789              		.cfi_def_cfa_register 7
 790 0006 F860     		str	r0, [r7, #12]
 791 0008 B960     		str	r1, [r7, #8]
 792 000a 111C     		mov	r1, r2
 793 000c 1A1C     		mov	r2, r3
 794 000e BB1D     		add	r3, r7, #6
 795 0010 1980     		strh	r1, [r3]
 796 0012 7B1D     		add	r3, r7, #5
 797 0014 1A70     		strb	r2, [r3]
 477:../Generated_Code/out_I2C.c ****   out_I2C_TDeviceData *DeviceDataPrv = (out_I2C_TDeviceData *)DeviceDataPtr;
 798              		.loc 1 477 0
 799 0016 FB68     		ldr	r3, [r7, #12]
 800 0018 7B61     		str	r3, [r7, #20]
 478:../Generated_Code/out_I2C.c **** 
 479:../Generated_Code/out_I2C.c ****   if (Size == 0x00U) {                 /* Test variable Size on zero */
 801              		.loc 1 479 0
 802 001a BB1D     		add	r3, r7, #6
 803 001c 1B88     		ldrh	r3, [r3]
 804 001e 002B     		cmp	r3, #0
 805 0020 01D1     		bne	.L33
 480:../Generated_Code/out_I2C.c ****     return ERR_OK;                     /* If zero then OK */
 806              		.loc 1 480 0
 807 0022 0023     		mov	r3, #0
 808 0024 85E0     		b	.L34
 809              	.L33:
 481:../Generated_Code/out_I2C.c ****   }
 482:../Generated_Code/out_I2C.c ****   if (SendStop == LDD_I2C_NO_SEND_STOP) { /* Test variable SendStop on supported value */
 810              		.loc 1 482 0
 811 0026 7B1D     		add	r3, r7, #5
 812 0028 1B78     		ldrb	r3, [r3]
 813 002a 002B     		cmp	r3, #0
 814 002c 01D1     		bne	.L35
 483:../Generated_Code/out_I2C.c ****     return ERR_PARAM_MODE;             /* If not supported value then error */
 815              		.loc 1 483 0
 816 002e 8123     		mov	r3, #129
 817 0030 7FE0     		b	.L34
 818              	.L35:
 484:../Generated_Code/out_I2C.c ****   }
 485:../Generated_Code/out_I2C.c ****   if (DeviceDataPrv->SendStop == LDD_I2C_SEND_STOP) {
 819              		.loc 1 485 0
 820 0032 7B69     		ldr	r3, [r7, #20]
 821 0034 5B78     		ldrb	r3, [r3, #1]
 822 0036 012B     		cmp	r3, #1
 823 0038 12D1     		bne	.L36
 486:../Generated_Code/out_I2C.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 824              		.loc 1 486 0
 825 003a 404B     		ldr	r3, .L44
 826 003c DB78     		ldrb	r3, [r3, #3]
 827 003e DBB2     		uxtb	r3, r3
 828 0040 1A1C     		mov	r2, r3
 829 0042 2023     		mov	r3, #32
 830 0044 1340     		and	r3, r2
 831 0046 09D1     		bne	.L37
 487:../Generated_Code/out_I2C.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 832              		.loc 1 487 0
 833 0048 7B69     		ldr	r3, [r7, #20]
 834 004a 1B78     		ldrb	r3, [r3]
 835 004c 1A1C     		mov	r2, r3
 836 004e 0123     		mov	r3, #1
 837 0050 1340     		and	r3, r2
 486:../Generated_Code/out_I2C.c ****     if ((I2C_PDD_GetBusStatus(I2C1_BASE_PTR) == I2C_PDD_BUS_BUSY) || /* Is the bus busy? */  \
 838              		.loc 1 486 0
 839 0052 03D1     		bne	.L37
 488:../Generated_Code/out_I2C.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 840              		.loc 1 488 0
 841 0054 7B69     		ldr	r3, [r7, #20]
 842 0056 5B88     		ldrh	r3, [r3, #2]
 487:../Generated_Code/out_I2C.c ****       ((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || \
 843              		.loc 1 487 0
 844 0058 002B     		cmp	r3, #0
 845 005a 0DD0     		beq	.L38
 846              	.L37:
 489:../Generated_Code/out_I2C.c ****       return ERR_BUSY;                 /* If yes then error */
 847              		.loc 1 489 0
 848 005c 0823     		mov	r3, #8
 849 005e 68E0     		b	.L34
 850              	.L36:
 490:../Generated_Code/out_I2C.c ****     }
 491:../Generated_Code/out_I2C.c ****   } else {
 492:../Generated_Code/out_I2C.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 851              		.loc 1 492 0
 852 0060 7B69     		ldr	r3, [r7, #20]
 853 0062 1B78     		ldrb	r3, [r3]
 854 0064 1A1C     		mov	r2, r3
 855 0066 0123     		mov	r3, #1
 856 0068 1340     		and	r3, r2
 857 006a 03D1     		bne	.L39
 493:../Generated_Code/out_I2C.c ****       (DeviceDataPrv->InpLenM != 0x00U)) {
 858              		.loc 1 493 0
 859 006c 7B69     		ldr	r3, [r7, #20]
 860 006e 5B88     		ldrh	r3, [r3, #2]
 492:../Generated_Code/out_I2C.c ****     if(((DeviceDataPrv->SerFlag & MASTER_IN_PROGRES) != 0x00U) || /* Is the bus busy? */  \
 861              		.loc 1 492 0
 862 0070 002B     		cmp	r3, #0
 863 0072 01D0     		beq	.L38
 864              	.L39:
 494:../Generated_Code/out_I2C.c ****       return ERR_BUSY;               /* If yes then error */
 865              		.loc 1 494 0
 866 0074 0823     		mov	r3, #8
 867 0076 5CE0     		b	.L34
 868              	.L38:
 869              	.LBB3:
 495:../Generated_Code/out_I2C.c ****     }
 496:../Generated_Code/out_I2C.c ****   }
 497:../Generated_Code/out_I2C.c ****   /* {Default RTOS Adapter} Critical section begin, general PE function is used */
 498:../Generated_Code/out_I2C.c ****   EnterCritical();
 870              		.loc 1 498 0
 871 0078 3B1C     		mov	r3, r7
 872 007a 1333     		add	r3, r3, #19
 873              	@ 498 "../Generated_Code/out_I2C.c" 1
 874 007c EFF31080 		MRS R0, PRIMASK
 875 0080 72B6     		CPSID i
 876 0082 1870     		STRB R0, [r3]
 877              	@ 0 "" 2
 878              		.code	16
 879 0084 2E4B     		ldr	r3, .L44+4
 880 0086 1B78     		ldrb	r3, [r3]
 881 0088 DBB2     		uxtb	r3, r3
 882 008a 0133     		add	r3, r3, #1
 883 008c DBB2     		uxtb	r3, r3
 884 008e 2C4A     		ldr	r2, .L44+4
 885 0090 191C     		add	r1, r3, #0
 886 0092 1170     		strb	r1, [r2]
 887 0094 012B     		cmp	r3, #1
 888 0096 04D1     		bne	.L40
 889              		.loc 1 498 0 is_stmt 0
 890 0098 3B1C     		mov	r3, r7
 891 009a 1333     		add	r3, r3, #19
 892 009c 1A78     		ldrb	r2, [r3]
 893 009e 294B     		ldr	r3, .L44+8
 894 00a0 1A70     		strb	r2, [r3]
 895              	.L40:
 896              	.LBE3:
 499:../Generated_Code/out_I2C.c ****   DeviceDataPrv->SerFlag |= MASTER_IN_PROGRES; /* Set flag "busy" */
 897              		.loc 1 499 0 is_stmt 1
 898 00a2 7B69     		ldr	r3, [r7, #20]
 899 00a4 1B78     		ldrb	r3, [r3]
 900 00a6 0122     		mov	r2, #1
 901 00a8 1343     		orr	r3, r2
 902 00aa DAB2     		uxtb	r2, r3
 903 00ac 7B69     		ldr	r3, [r7, #20]
 904 00ae 1A70     		strb	r2, [r3]
 500:../Generated_Code/out_I2C.c ****   DeviceDataPrv->InpPtrM = (uint8_t *)BufferPtr; /* Save pointer to data for reception */
 905              		.loc 1 500 0
 906 00b0 7B69     		ldr	r3, [r7, #20]
 907 00b2 BA68     		ldr	r2, [r7, #8]
 908 00b4 5A60     		str	r2, [r3, #4]
 501:../Generated_Code/out_I2C.c ****   DeviceDataPrv->InpLenM = Size;       /* Set the counter of input bufer's content */
 909              		.loc 1 501 0
 910 00b6 7B69     		ldr	r3, [r7, #20]
 911 00b8 BA1D     		add	r2, r7, #6
 912 00ba 1288     		ldrh	r2, [r2]
 913 00bc 5A80     		strh	r2, [r3, #2]
 502:../Generated_Code/out_I2C.c ****   DeviceDataPrv->SendStop = SendStop;  /* Set generating stop condition */
 914              		.loc 1 502 0
 915 00be 7B69     		ldr	r3, [r7, #20]
 916 00c0 7A1D     		add	r2, r7, #5
 917 00c2 1278     		ldrb	r2, [r2]
 918 00c4 5A70     		strb	r2, [r3, #1]
 503:../Generated_Code/out_I2C.c ****   I2C_PDD_SetTransmitMode(I2C1_BASE_PTR, I2C_PDD_TX_DIRECTION); /* Set TX mode */
 919              		.loc 1 503 0
 920 00c6 1D4B     		ldr	r3, .L44
 921 00c8 1C4A     		ldr	r2, .L44
 922 00ca 9278     		ldrb	r2, [r2, #2]
 923 00cc D2B2     		uxtb	r2, r2
 924 00ce D2B2     		uxtb	r2, r2
 925 00d0 1021     		mov	r1, #16
 926 00d2 0A43     		orr	r2, r1
 927 00d4 D2B2     		uxtb	r2, r2
 928 00d6 D2B2     		uxtb	r2, r2
 929 00d8 9A70     		strb	r2, [r3, #2]
 504:../Generated_Code/out_I2C.c ****   if (I2C_PDD_GetMasterMode(I2C1_BASE_PTR) == I2C_PDD_MASTER_MODE) { /* Is device in master mode? *
 930              		.loc 1 504 0
 931 00da 184B     		ldr	r3, .L44
 932 00dc 9B78     		ldrb	r3, [r3, #2]
 933 00de DBB2     		uxtb	r3, r3
 934 00e0 1A1C     		mov	r2, r3
 935 00e2 2023     		mov	r3, #32
 936 00e4 1340     		and	r3, r2
 937 00e6 08D0     		beq	.L41
 505:../Generated_Code/out_I2C.c ****     I2C_PDD_RepeatStart(I2C1_BASE_PTR); /* If yes then repeat start cycle generated */
 938              		.loc 1 505 0
 939 00e8 144B     		ldr	r3, .L44
 940 00ea 144A     		ldr	r2, .L44
 941 00ec 9278     		ldrb	r2, [r2, #2]
 942 00ee D2B2     		uxtb	r2, r2
 943 00f0 0421     		mov	r1, #4
 944 00f2 0A43     		orr	r2, r1
 945 00f4 D2B2     		uxtb	r2, r2
 946 00f6 9A70     		strb	r2, [r3, #2]
 947 00f8 09E0     		b	.L42
 948              	.L41:
 506:../Generated_Code/out_I2C.c ****   } else {
 507:../Generated_Code/out_I2C.c ****     I2C_PDD_SetMasterMode(I2C1_BASE_PTR, I2C_PDD_MASTER_MODE); /* If no then start signal generated
 949              		.loc 1 507 0
 950 00fa 104B     		ldr	r3, .L44
 951 00fc 0F4A     		ldr	r2, .L44
 952 00fe 9278     		ldrb	r2, [r2, #2]
 953 0100 D2B2     		uxtb	r2, r2
 954 0102 D2B2     		uxtb	r2, r2
 955 0104 2021     		mov	r1, #32
 956 0106 0A43     		orr	r2, r1
 957 0108 D2B2     		uxtb	r2, r2
 958 010a D2B2     		uxtb	r2, r2
 959 010c 9A70     		strb	r2, [r3, #2]
 960              	.L42:
 508:../Generated_Code/out_I2C.c ****   }
 509:../Generated_Code/out_I2C.c ****   I2C_PDD_WriteDataReg(I2C1_BASE_PTR, 0x01U); /* Send slave address */
 961              		.loc 1 509 0
 962 010e 0B4B     		ldr	r3, .L44
 963 0110 0122     		mov	r2, #1
 964 0112 1A71     		strb	r2, [r3, #4]
 510:../Generated_Code/out_I2C.c ****   /* {Default RTOS Adapter} Critical section end, general PE function is used */
 511:../Generated_Code/out_I2C.c ****   ExitCritical();
 965              		.loc 1 511 0
 966 0114 0A4B     		ldr	r3, .L44+4
 967 0116 1B78     		ldrb	r3, [r3]
 968 0118 DBB2     		uxtb	r3, r3
 969 011a 013B     		sub	r3, r3, #1
 970 011c DBB2     		uxtb	r3, r3
 971 011e 084A     		ldr	r2, .L44+4
 972 0120 191C     		add	r1, r3, #0
 973 0122 1170     		strb	r1, [r2]
 974 0124 002B     		cmp	r3, #0
 975 0126 03D1     		bne	.L43
 976              		.loc 1 511 0 is_stmt 0
 977 0128 064B     		ldr	r3, .L44+8
 978              	@ 511 "../Generated_Code/out_I2C.c" 1
 979 012a 1878     		ldrb r0, [r3]
 980 012c 80F31088 		msr PRIMASK,r0;
 981              		
 982              	@ 0 "" 2
 983              		.code	16
 984              	.L43:
 512:../Generated_Code/out_I2C.c ****   return ERR_OK;                       /* OK */
 985              		.loc 1 512 0 is_stmt 1
 986 0130 0023     		mov	r3, #0
 987              	.L34:
 513:../Generated_Code/out_I2C.c **** }
 988              		.loc 1 513 0
 989 0132 181C     		mov	r0, r3
 990 0134 BD46     		mov	sp, r7
 991 0136 06B0     		add	sp, sp, #24
 992              		@ sp needed for prologue
 993 0138 80BD     		pop	{r7, pc}
 994              	.L45:
 995 013a C046     		.align	2
 996              	.L44:
 997 013c 00700640 		.word	1074163712
 998 0140 00000000 		.word	SR_lock
 999 0144 00000000 		.word	SR_reg
 1000              		.cfi_endproc
 1001              	.LFE3:
 1003              		.text
 1004              	.Letext0:
 1005              		.file 2 "D:/CodeWarrior/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 1006              		.file 3 "D:/PlikiI/Synergia/Jacht/workspace_yacht/I2C_1/Generated_Code/PE_Types.h"
 1007              		.file 4 "D:/CodeWarrior/CW MCU v10.6/MCU/ProcessorExpert/lib/Kinetis/iofiles/MKL25Z4.h"
 1008              		.file 5 "D:/PlikiI/Synergia/Jacht/workspace_yacht/I2C_1/Generated_Code/Cpu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 out_I2C.c
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:18     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:21     .bss.DeviceDataPrv__DEFAULT_RTOS_ALLOC:00000000 DeviceDataPrv__DEFAULT_RTOS_ALLOC
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:24     .bss.INT_I2C1__DEFAULT_RTOS_ISRPARAM:00000000 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:27     .bss.INT_I2C1__DEFAULT_RTOS_ISRPARAM:00000000 INT_I2C1__DEFAULT_RTOS_ISRPARAM
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:30     .text.out_I2C_Interrupt:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:35     .text.out_I2C_Interrupt:00000000 out_I2C_Interrupt
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:362    .text.out_I2C_Interrupt:00000200 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:368    .text.out_I2C_Init:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:373    .text.out_I2C_Init:00000000 out_I2C_Init
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:531    .text.out_I2C_Init:000000ec $d
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:545    .text.out_I2C_MasterSendBlock:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:550    .text.out_I2C_MasterSendBlock:00000000 out_I2C_MasterSendBlock
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:763    .text.out_I2C_MasterSendBlock:00000130 $d
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:770    .text.out_I2C_MasterReceiveBlock:00000000 $t
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:775    .text.out_I2C_MasterReceiveBlock:00000000 out_I2C_MasterReceiveBlock
C:\Users\SKRA~1\AppData\Local\Temp\ccJ6xQAb.s:997    .text.out_I2C_MasterReceiveBlock:0000013c $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
out_I2C_OnMasterBlockSent
out_I2C_OnMasterBlockReceived
PE_LDD_DeviceDataList
SR_lock
SR_reg
